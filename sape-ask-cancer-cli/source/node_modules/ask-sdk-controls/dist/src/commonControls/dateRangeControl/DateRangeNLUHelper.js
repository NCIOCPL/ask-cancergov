"use strict";
/*
 * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.findTargetCategory = exports.handleCustomSlots = exports.generateDatesInputGroups = void 0;
const tslib_1 = require("tslib");
// Convert complicated utterance into one or two simple tasks
// E.G. Set date from A to B -> [Set startDate to A, Set endDate to B]
// This function also translate action & target to actionCateGory & targetCategory
// Thus no need to translate action & target in reset of the code
const lodash_1 = tslib_1.__importDefault(require("lodash"));
const DateRangeControlIntent_1 = require("../../intents/DateRangeControlIntent");
const DateHelper_1 = require("./DateHelper");
const DateRangeControl_1 = require("./DateRangeControl");
// Break down complicated utterance into two simple utterances
// E.G. Set start date to 2017 and end date to 2018 --> ['set start date to 2017', 'set end date to 2018']
function generateDatesInputGroups(props, input) {
    // translate all custom target slotTypes to targetCategory
    handleCustomSlots(props.interactionModel, input);
    const inputs = [];
    const inputA = {
        action: undefined,
        target: undefined,
        value: ''
    };
    const inputB = {
        action: undefined,
        target: undefined,
        value: ''
    };
    // Action exist
    if (DateRangeControlIntent_1.hasOneOrMoreActions(input)) {
        if (input.action !== undefined) {
            inputA.action = input.action;
            inputB.action = input.action;
        }
        else {
            inputA.action = input['action.a'];
            inputB.action = input['action.b'];
        }
    }
    // Target exist
    if (DateRangeControlIntent_1.hasOneOrMoreTargets(input)) {
        if (input.target !== undefined) {
            inputA.target = input.target;
            inputB.target = input.target;
        }
        else {
            inputA.target = input['target.a'];
            inputB.target = input['target.b'];
        }
    }
    // value exist
    if (DateRangeControlIntent_1.hasOneOrMoreValues(input)) {
        if (input['AMAZON.DATE'] !== undefined) {
            inputA.value = input['AMAZON.DATE'];
            inputB.value = input['AMAZON.DATE'];
        }
        else {
            inputA.value = input['AMAZON.DATE.a'];
            inputB.value = input['AMAZON.DATE.b'];
        }
    }
    // deduplicate
    // E.G. 'set date to 2019' will be converted to [{'set', 'date', '2019'}, {'set', 'date', '2019'}]
    // need to delete the duplicate one in this scenario
    if (inputA.action === inputB.action && inputA.target === inputB.target && inputA.value === inputB.value) {
        inputs.push(inputA);
    }
    else {
        inputs.push(inputA);
        inputs.push(inputB);
    }
    resolveAmbiguityTargets(inputs);
    return inputs;
}
exports.generateDatesInputGroups = generateDatesInputGroups;
// translate custom target to TargetCategory
function handleCustomSlots(nlu, input) {
    var _a, _b, _c;
    // map target to right targetCategory
    input.target = (_a = findTargetCategory(nlu.targets, input.target)) !== null && _a !== void 0 ? _a : undefined;
    input['target.a'] = (_b = findTargetCategory(nlu.targets, input['target.a'])) !== null && _b !== void 0 ? _b : undefined;
    input['target.b'] = (_c = findTargetCategory(nlu.targets, input['target.b'])) !== null && _c !== void 0 ? _c : undefined;
}
exports.handleCustomSlots = handleCustomSlots;
// Translate slotValue id into target category
function findTargetCategory(targets, input) {
    // E.G. 'date' is an ambiguity target, which may refer to start date or end date
    if (lodash_1.default.includes(targets.startDate, input) && lodash_1.default.includes(targets.endDate, input)) {
        return DateRangeControl_1.TargetCategory.Either;
    }
    if (lodash_1.default.includes(targets.startDate, input)) {
        return DateRangeControl_1.TargetCategory.StartDate;
    }
    if (lodash_1.default.includes(targets.endDate, input)) {
        return DateRangeControl_1.TargetCategory.EndDate;
    }
    return undefined;
}
exports.findTargetCategory = findTargetCategory;
// Only TargetCategory.StartDate and TargetCategory.EndDate is regarded as clear target
function isNotClearTarget(input) {
    if (input === undefined) {
        return true;
    }
    if (input === DateRangeControl_1.TargetCategory.Either || input === DateRangeControl_1.TargetCategory.Both || input === DateRangeControl_1.TargetCategory.Neither) {
        return true;
    }
    return false;
}
// if two values provided without clear target
// generate clear targets, the earlier date will be considered as start date
// E.G. 2020 back to 2017 --> startDate: 2017, endDate: 2020
function resolveAmbiguityTargets(inputs) {
    if (inputs[0] !== undefined && inputs[1] !== undefined && isNotClearTarget(inputs[0].target) && isNotClearTarget(inputs[1].target)) {
        const date1 = DateHelper_1.alexaDateFormatToDate(inputs[0].value);
        const date2 = DateHelper_1.alexaDateFormatToDate(inputs[0].value);
        if (date1 > date2) {
            inputs[0].target = DateRangeControl_1.TargetCategory.EndDate;
            inputs[1].target = DateRangeControl_1.TargetCategory.StartDate;
        }
        else {
            inputs[0].target = DateRangeControl_1.TargetCategory.StartDate;
            inputs[1].target = DateRangeControl_1.TargetCategory.EndDate;
        }
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRGF0ZVJhbmdlTkxVSGVscGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL2NvbW1vbkNvbnRyb2xzL2RhdGVSYW5nZUNvbnRyb2wvRGF0ZVJhbmdlTkxVSGVscGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTs7Ozs7Ozs7Ozs7R0FXRzs7OztBQUVILDZEQUE2RDtBQUM3RCxzRUFBc0U7QUFDdEUsa0ZBQWtGO0FBQ2xGLGlFQUFpRTtBQUVqRSw0REFBdUI7QUFDdkIsaUZBQWlKO0FBRWpKLDZDQUFxRDtBQUNyRCx5REFBK0k7QUFRL0ksOERBQThEO0FBQzlELDBHQUEwRztBQUMxRyxTQUFnQix3QkFBd0IsQ0FBQyxLQUEwQyxFQUFFLEtBQWtDO0lBQ25ILDBEQUEwRDtJQUMxRCxpQkFBaUIsQ0FBQyxLQUFLLENBQUMsZ0JBQWdCLEVBQUUsS0FBSyxDQUFDLENBQUM7SUFFakQsTUFBTSxNQUFNLEdBQWtDLEVBQUUsQ0FBQztJQUNqRCxNQUFNLE1BQU0sR0FBZ0M7UUFDeEMsTUFBTSxFQUFFLFNBQVM7UUFDakIsTUFBTSxFQUFFLFNBQVM7UUFDakIsS0FBSyxFQUFFLEVBQUU7S0FDWixDQUFDO0lBRUYsTUFBTSxNQUFNLEdBQWdDO1FBQ3hDLE1BQU0sRUFBRSxTQUFTO1FBQ2pCLE1BQU0sRUFBRSxTQUFTO1FBQ2pCLEtBQUssRUFBRSxFQUFFO0tBQ1osQ0FBQztJQUNGLGVBQWU7SUFDZixJQUFJLDRDQUFtQixDQUFDLEtBQUssQ0FBQyxFQUFFO1FBQzVCLElBQUksS0FBSyxDQUFDLE1BQU0sS0FBSyxTQUFTLEVBQUU7WUFDNUIsTUFBTSxDQUFDLE1BQU0sR0FBRyxLQUFLLENBQUMsTUFBTSxDQUFDO1lBQzdCLE1BQU0sQ0FBQyxNQUFNLEdBQUcsS0FBSyxDQUFDLE1BQU0sQ0FBQztTQUNoQzthQUFNO1lBQ0gsTUFBTSxDQUFDLE1BQU0sR0FBRyxLQUFLLENBQUMsVUFBVSxDQUFFLENBQUM7WUFDbkMsTUFBTSxDQUFDLE1BQU0sR0FBRyxLQUFLLENBQUMsVUFBVSxDQUFFLENBQUM7U0FDdEM7S0FDSjtJQUVELGVBQWU7SUFDZixJQUFJLDRDQUFtQixDQUFDLEtBQUssQ0FBQyxFQUFFO1FBQzVCLElBQUksS0FBSyxDQUFDLE1BQU0sS0FBSyxTQUFTLEVBQUU7WUFDNUIsTUFBTSxDQUFDLE1BQU0sR0FBRyxLQUFLLENBQUMsTUFBd0IsQ0FBQztZQUMvQyxNQUFNLENBQUMsTUFBTSxHQUFHLEtBQUssQ0FBQyxNQUF3QixDQUFDO1NBQ2xEO2FBQU07WUFDSCxNQUFNLENBQUMsTUFBTSxHQUFHLEtBQUssQ0FBQyxVQUFVLENBQW9CLENBQUM7WUFDckQsTUFBTSxDQUFDLE1BQU0sR0FBRyxLQUFLLENBQUMsVUFBVSxDQUFvQixDQUFDO1NBQ3hEO0tBRUo7SUFDRCxjQUFjO0lBQ2QsSUFBSSwyQ0FBa0IsQ0FBQyxLQUFLLENBQUMsRUFBRTtRQUUzQixJQUFJLEtBQUssQ0FBQyxhQUFhLENBQUMsS0FBSyxTQUFTLEVBQUU7WUFDcEMsTUFBTSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUMsYUFBYSxDQUFDLENBQUM7WUFDcEMsTUFBTSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUMsYUFBYSxDQUFDLENBQUM7U0FDdkM7YUFBTTtZQUNILE1BQU0sQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDLGVBQWUsQ0FBRSxDQUFDO1lBQ3ZDLE1BQU0sQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDLGVBQWUsQ0FBRSxDQUFDO1NBQzFDO0tBQ0o7SUFFRCxjQUFjO0lBQ2Qsa0dBQWtHO0lBQ2xHLG9EQUFvRDtJQUNwRCxJQUFJLE1BQU0sQ0FBQyxNQUFNLEtBQUssTUFBTSxDQUFDLE1BQU0sSUFBSSxNQUFNLENBQUMsTUFBTSxLQUFLLE1BQU0sQ0FBQyxNQUFNLElBQUksTUFBTSxDQUFDLEtBQUssS0FBSyxNQUFNLENBQUMsS0FBSyxFQUFFO1FBQ3JHLE1BQU0sQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7S0FDdkI7U0FBTTtRQUNILE1BQU0sQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDcEIsTUFBTSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztLQUN2QjtJQUVELHVCQUF1QixDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBRWhDLE9BQU8sTUFBTSxDQUFDO0FBQ2xCLENBQUM7QUEvREQsNERBK0RDO0FBRUQsNENBQTRDO0FBQzVDLFNBQWdCLGlCQUFpQixDQUFDLEdBQW9ELEVBQUUsS0FBa0M7O0lBRXRILHFDQUFxQztJQUNyQyxLQUFLLENBQUMsTUFBTSxTQUFHLGtCQUFrQixDQUFDLEdBQUcsQ0FBQyxPQUFPLEVBQUUsS0FBSyxDQUFDLE1BQU0sQ0FBQyxtQ0FBSSxTQUFTLENBQUM7SUFDMUUsS0FBSyxDQUFDLFVBQVUsQ0FBQyxTQUFHLGtCQUFrQixDQUFDLEdBQUcsQ0FBQyxPQUFPLEVBQUUsS0FBSyxDQUFDLFVBQVUsQ0FBQyxDQUFDLG1DQUFJLFNBQVMsQ0FBQztJQUNwRixLQUFLLENBQUMsVUFBVSxDQUFDLFNBQUcsa0JBQWtCLENBQUMsR0FBRyxDQUFDLE9BQU8sRUFBRSxLQUFLLENBQUMsVUFBVSxDQUFDLENBQUMsbUNBQUksU0FBUyxDQUFDO0FBQ3hGLENBQUM7QUFORCw4Q0FNQztBQUVELDhDQUE4QztBQUM5QyxTQUFnQixrQkFBa0IsQ0FBQyxPQUFvQyxFQUFFLEtBQXlCO0lBQzlGLGdGQUFnRjtJQUNoRixJQUFJLGdCQUFDLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxTQUFTLEVBQUUsS0FBSyxDQUFDLElBQUksZ0JBQUMsQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLE9BQU8sRUFBRSxLQUFLLENBQUMsRUFBRTtRQUM1RSxPQUFPLGlDQUFjLENBQUMsTUFBTSxDQUFDO0tBQ2hDO0lBQ0QsSUFBSSxnQkFBQyxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsU0FBUyxFQUFFLEtBQUssQ0FBQyxFQUFFO1FBQ3RDLE9BQU8saUNBQWMsQ0FBQyxTQUFTLENBQUM7S0FDbkM7SUFDRCxJQUFJLGdCQUFDLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxPQUFPLEVBQUUsS0FBSyxDQUFDLEVBQUU7UUFDcEMsT0FBTyxpQ0FBYyxDQUFDLE9BQU8sQ0FBQztLQUNqQztJQUNELE9BQU8sU0FBUyxDQUFDO0FBQ3JCLENBQUM7QUFaRCxnREFZQztBQUVELHVGQUF1RjtBQUN2RixTQUFTLGdCQUFnQixDQUFDLEtBQWlDO0lBQ3ZELElBQUksS0FBSyxLQUFLLFNBQVMsRUFBRTtRQUNyQixPQUFPLElBQUksQ0FBQztLQUNmO0lBQ0QsSUFBSSxLQUFLLEtBQUssaUNBQWMsQ0FBQyxNQUFNLElBQUksS0FBSyxLQUFLLGlDQUFjLENBQUMsSUFBSSxJQUFJLEtBQUssS0FBSyxpQ0FBYyxDQUFDLE9BQU8sRUFBRTtRQUN0RyxPQUFPLElBQUksQ0FBQztLQUNmO0lBQ0QsT0FBTyxLQUFLLENBQUM7QUFDakIsQ0FBQztBQUVELDhDQUE4QztBQUM5Qyw0RUFBNEU7QUFDNUUsNERBQTREO0FBQzVELFNBQVMsdUJBQXVCLENBQUMsTUFBcUM7SUFFbEUsSUFBSSxNQUFNLENBQUMsQ0FBQyxDQUFDLEtBQUssU0FBUyxJQUFJLE1BQU0sQ0FBQyxDQUFDLENBQUMsS0FBSyxTQUFTLElBQUksZ0JBQWdCLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxJQUFJLGdCQUFnQixDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsRUFBRTtRQUNoSSxNQUFNLEtBQUssR0FBUyxrQ0FBcUIsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDM0QsTUFBTSxLQUFLLEdBQVMsa0NBQXFCLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQzNELElBQUksS0FBSyxHQUFHLEtBQUssRUFBRTtZQUNmLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLEdBQUcsaUNBQWMsQ0FBQyxPQUFPLENBQUM7WUFDMUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sR0FBRyxpQ0FBYyxDQUFDLFNBQVMsQ0FBQztTQUMvQzthQUFNO1lBQ0gsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sR0FBRyxpQ0FBYyxDQUFDLFNBQVMsQ0FBQztZQUM1QyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxHQUFHLGlDQUFjLENBQUMsT0FBTyxDQUFDO1NBQzdDO0tBQ0o7QUFDTCxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIENvcHlyaWdodCAyMDIwIEFtYXpvbi5jb20sIEluYy4gb3IgaXRzIGFmZmlsaWF0ZXMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpLlxuICogWW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogQSBjb3B5IG9mIHRoZSBMaWNlbnNlIGlzIGxvY2F0ZWQgYXRcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogb3IgaW4gdGhlIFwibGljZW5zZVwiIGZpbGUgYWNjb21wYW55aW5nIHRoaXMgZmlsZS4gVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkXG4gKiBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXJcbiAqIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nXG4gKiBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLy8gQ29udmVydCBjb21wbGljYXRlZCB1dHRlcmFuY2UgaW50byBvbmUgb3IgdHdvIHNpbXBsZSB0YXNrc1xuLy8gRS5HLiBTZXQgZGF0ZSBmcm9tIEEgdG8gQiAtPiBbU2V0IHN0YXJ0RGF0ZSB0byBBLCBTZXQgZW5kRGF0ZSB0byBCXVxuLy8gVGhpcyBmdW5jdGlvbiBhbHNvIHRyYW5zbGF0ZSBhY3Rpb24gJiB0YXJnZXQgdG8gYWN0aW9uQ2F0ZUdvcnkgJiB0YXJnZXRDYXRlZ29yeVxuLy8gVGh1cyBubyBuZWVkIHRvIHRyYW5zbGF0ZSBhY3Rpb24gJiB0YXJnZXQgaW4gcmVzZXQgb2YgdGhlIGNvZGVcblxuaW1wb3J0IF8gZnJvbSBcImxvZGFzaFwiO1xuaW1wb3J0IHsgRGF0ZVJhbmdlQ29udHJvbEludGVudFNsb3RzLCBoYXNPbmVPck1vcmVBY3Rpb25zLCBoYXNPbmVPck1vcmVUYXJnZXRzLCBoYXNPbmVPck1vcmVWYWx1ZXMgfSBmcm9tICcuLi8uLi9pbnRlbnRzL0RhdGVSYW5nZUNvbnRyb2xJbnRlbnQnO1xuaW1wb3J0IHsgRGVlcFJlcXVpcmVkIH0gZnJvbSAnLi4vLi4vdXRpbHMvRGVlcFJlcXVpcmVkJztcbmltcG9ydCB7IGFsZXhhRGF0ZUZvcm1hdFRvRGF0ZSB9IGZyb20gJy4vRGF0ZUhlbHBlcic7XG5pbXBvcnQgeyBEYXRlUmFuZ2VDb250cm9sSW50ZXJhY3Rpb25Nb2RlbFByb3BzLCBEYXRlUmFuZ2VDb250cm9sUHJvcHMsIERhdGVSYW5nZUNvbnRyb2xUYXJnZXRQcm9wcywgVGFyZ2V0Q2F0ZWdvcnkgfSBmcm9tICcuL0RhdGVSYW5nZUNvbnRyb2wnO1xuXG5leHBvcnQgaW50ZXJmYWNlIERhdGVSYW5nZUNvbnRyb2xJbnRlbnRJbnB1dCB7XG4gICAgYWN0aW9uOiBzdHJpbmcgfCB1bmRlZmluZWQsXG4gICAgdGFyZ2V0OiBUYXJnZXRDYXRlZ29yeSB8IHVuZGVmaW5lZCxcbiAgICB2YWx1ZTogc3RyaW5nXG59XG5cbi8vIEJyZWFrIGRvd24gY29tcGxpY2F0ZWQgdXR0ZXJhbmNlIGludG8gdHdvIHNpbXBsZSB1dHRlcmFuY2VzXG4vLyBFLkcuIFNldCBzdGFydCBkYXRlIHRvIDIwMTcgYW5kIGVuZCBkYXRlIHRvIDIwMTggLS0+IFsnc2V0IHN0YXJ0IGRhdGUgdG8gMjAxNycsICdzZXQgZW5kIGRhdGUgdG8gMjAxOCddXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVEYXRlc0lucHV0R3JvdXBzKHByb3BzOiBEZWVwUmVxdWlyZWQ8RGF0ZVJhbmdlQ29udHJvbFByb3BzPiwgaW5wdXQ6IERhdGVSYW5nZUNvbnRyb2xJbnRlbnRTbG90cyk6IERhdGVSYW5nZUNvbnRyb2xJbnRlbnRJbnB1dFtdIHtcbiAgICAvLyB0cmFuc2xhdGUgYWxsIGN1c3RvbSB0YXJnZXQgc2xvdFR5cGVzIHRvIHRhcmdldENhdGVnb3J5XG4gICAgaGFuZGxlQ3VzdG9tU2xvdHMocHJvcHMuaW50ZXJhY3Rpb25Nb2RlbCwgaW5wdXQpO1xuXG4gICAgY29uc3QgaW5wdXRzOiBEYXRlUmFuZ2VDb250cm9sSW50ZW50SW5wdXRbXSA9IFtdO1xuICAgIGNvbnN0IGlucHV0QTogRGF0ZVJhbmdlQ29udHJvbEludGVudElucHV0ID0ge1xuICAgICAgICBhY3Rpb246IHVuZGVmaW5lZCxcbiAgICAgICAgdGFyZ2V0OiB1bmRlZmluZWQsXG4gICAgICAgIHZhbHVlOiAnJ1xuICAgIH07XG5cbiAgICBjb25zdCBpbnB1dEI6IERhdGVSYW5nZUNvbnRyb2xJbnRlbnRJbnB1dCA9IHtcbiAgICAgICAgYWN0aW9uOiB1bmRlZmluZWQsXG4gICAgICAgIHRhcmdldDogdW5kZWZpbmVkLFxuICAgICAgICB2YWx1ZTogJydcbiAgICB9O1xuICAgIC8vIEFjdGlvbiBleGlzdFxuICAgIGlmIChoYXNPbmVPck1vcmVBY3Rpb25zKGlucHV0KSkge1xuICAgICAgICBpZiAoaW5wdXQuYWN0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlucHV0QS5hY3Rpb24gPSBpbnB1dC5hY3Rpb247XG4gICAgICAgICAgICBpbnB1dEIuYWN0aW9uID0gaW5wdXQuYWN0aW9uO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW5wdXRBLmFjdGlvbiA9IGlucHV0WydhY3Rpb24uYSddITtcbiAgICAgICAgICAgIGlucHV0Qi5hY3Rpb24gPSBpbnB1dFsnYWN0aW9uLmInXSE7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUYXJnZXQgZXhpc3RcbiAgICBpZiAoaGFzT25lT3JNb3JlVGFyZ2V0cyhpbnB1dCkpIHtcbiAgICAgICAgaWYgKGlucHV0LnRhcmdldCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpbnB1dEEudGFyZ2V0ID0gaW5wdXQudGFyZ2V0IGFzIFRhcmdldENhdGVnb3J5O1xuICAgICAgICAgICAgaW5wdXRCLnRhcmdldCA9IGlucHV0LnRhcmdldCBhcyBUYXJnZXRDYXRlZ29yeTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlucHV0QS50YXJnZXQgPSBpbnB1dFsndGFyZ2V0LmEnXSEgYXMgVGFyZ2V0Q2F0ZWdvcnk7XG4gICAgICAgICAgICBpbnB1dEIudGFyZ2V0ID0gaW5wdXRbJ3RhcmdldC5iJ10hIGFzIFRhcmdldENhdGVnb3J5O1xuICAgICAgICB9XG5cbiAgICB9XG4gICAgLy8gdmFsdWUgZXhpc3RcbiAgICBpZiAoaGFzT25lT3JNb3JlVmFsdWVzKGlucHV0KSkge1xuXG4gICAgICAgIGlmIChpbnB1dFsnQU1BWk9OLkRBVEUnXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpbnB1dEEudmFsdWUgPSBpbnB1dFsnQU1BWk9OLkRBVEUnXTtcbiAgICAgICAgICAgIGlucHV0Qi52YWx1ZSA9IGlucHV0WydBTUFaT04uREFURSddO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW5wdXRBLnZhbHVlID0gaW5wdXRbJ0FNQVpPTi5EQVRFLmEnXSE7XG4gICAgICAgICAgICBpbnB1dEIudmFsdWUgPSBpbnB1dFsnQU1BWk9OLkRBVEUuYiddITtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGRlZHVwbGljYXRlXG4gICAgLy8gRS5HLiAnc2V0IGRhdGUgdG8gMjAxOScgd2lsbCBiZSBjb252ZXJ0ZWQgdG8gW3snc2V0JywgJ2RhdGUnLCAnMjAxOSd9LCB7J3NldCcsICdkYXRlJywgJzIwMTknfV1cbiAgICAvLyBuZWVkIHRvIGRlbGV0ZSB0aGUgZHVwbGljYXRlIG9uZSBpbiB0aGlzIHNjZW5hcmlvXG4gICAgaWYgKGlucHV0QS5hY3Rpb24gPT09IGlucHV0Qi5hY3Rpb24gJiYgaW5wdXRBLnRhcmdldCA9PT0gaW5wdXRCLnRhcmdldCAmJiBpbnB1dEEudmFsdWUgPT09IGlucHV0Qi52YWx1ZSkge1xuICAgICAgICBpbnB1dHMucHVzaChpbnB1dEEpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGlucHV0cy5wdXNoKGlucHV0QSk7XG4gICAgICAgIGlucHV0cy5wdXNoKGlucHV0Qik7XG4gICAgfVxuXG4gICAgcmVzb2x2ZUFtYmlndWl0eVRhcmdldHMoaW5wdXRzKTtcblxuICAgIHJldHVybiBpbnB1dHM7XG59XG5cbi8vIHRyYW5zbGF0ZSBjdXN0b20gdGFyZ2V0IHRvIFRhcmdldENhdGVnb3J5XG5leHBvcnQgZnVuY3Rpb24gaGFuZGxlQ3VzdG9tU2xvdHMobmx1OiBSZXF1aXJlZDxEYXRlUmFuZ2VDb250cm9sSW50ZXJhY3Rpb25Nb2RlbFByb3BzPiwgaW5wdXQ6IERhdGVSYW5nZUNvbnRyb2xJbnRlbnRTbG90cyk6IHZvaWQge1xuXG4gICAgLy8gbWFwIHRhcmdldCB0byByaWdodCB0YXJnZXRDYXRlZ29yeVxuICAgIGlucHV0LnRhcmdldCA9IGZpbmRUYXJnZXRDYXRlZ29yeShubHUudGFyZ2V0cywgaW5wdXQudGFyZ2V0KSA/PyB1bmRlZmluZWQ7XG4gICAgaW5wdXRbJ3RhcmdldC5hJ10gPSBmaW5kVGFyZ2V0Q2F0ZWdvcnkobmx1LnRhcmdldHMsIGlucHV0Wyd0YXJnZXQuYSddKSA/PyB1bmRlZmluZWQ7XG4gICAgaW5wdXRbJ3RhcmdldC5iJ10gPSBmaW5kVGFyZ2V0Q2F0ZWdvcnkobmx1LnRhcmdldHMsIGlucHV0Wyd0YXJnZXQuYiddKSA/PyB1bmRlZmluZWQ7XG59XG5cbi8vIFRyYW5zbGF0ZSBzbG90VmFsdWUgaWQgaW50byB0YXJnZXQgY2F0ZWdvcnlcbmV4cG9ydCBmdW5jdGlvbiBmaW5kVGFyZ2V0Q2F0ZWdvcnkodGFyZ2V0czogRGF0ZVJhbmdlQ29udHJvbFRhcmdldFByb3BzLCBpbnB1dDogc3RyaW5nIHwgdW5kZWZpbmVkKTogVGFyZ2V0Q2F0ZWdvcnkgfCB1bmRlZmluZWQge1xuICAgIC8vIEUuRy4gJ2RhdGUnIGlzIGFuIGFtYmlndWl0eSB0YXJnZXQsIHdoaWNoIG1heSByZWZlciB0byBzdGFydCBkYXRlIG9yIGVuZCBkYXRlXG4gICAgaWYgKF8uaW5jbHVkZXModGFyZ2V0cy5zdGFydERhdGUsIGlucHV0KSAmJiBfLmluY2x1ZGVzKHRhcmdldHMuZW5kRGF0ZSwgaW5wdXQpKSB7XG4gICAgICAgIHJldHVybiBUYXJnZXRDYXRlZ29yeS5FaXRoZXI7XG4gICAgfVxuICAgIGlmIChfLmluY2x1ZGVzKHRhcmdldHMuc3RhcnREYXRlLCBpbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuIFRhcmdldENhdGVnb3J5LlN0YXJ0RGF0ZTtcbiAgICB9XG4gICAgaWYgKF8uaW5jbHVkZXModGFyZ2V0cy5lbmREYXRlLCBpbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuIFRhcmdldENhdGVnb3J5LkVuZERhdGU7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbi8vIE9ubHkgVGFyZ2V0Q2F0ZWdvcnkuU3RhcnREYXRlIGFuZCBUYXJnZXRDYXRlZ29yeS5FbmREYXRlIGlzIHJlZ2FyZGVkIGFzIGNsZWFyIHRhcmdldFxuZnVuY3Rpb24gaXNOb3RDbGVhclRhcmdldChpbnB1dDogVGFyZ2V0Q2F0ZWdvcnkgfCB1bmRlZmluZWQpOiBib29sZWFuIHtcbiAgICBpZiAoaW5wdXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGlucHV0ID09PSBUYXJnZXRDYXRlZ29yeS5FaXRoZXIgfHwgaW5wdXQgPT09IFRhcmdldENhdGVnb3J5LkJvdGggfHwgaW5wdXQgPT09IFRhcmdldENhdGVnb3J5Lk5laXRoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuLy8gaWYgdHdvIHZhbHVlcyBwcm92aWRlZCB3aXRob3V0IGNsZWFyIHRhcmdldFxuLy8gZ2VuZXJhdGUgY2xlYXIgdGFyZ2V0cywgdGhlIGVhcmxpZXIgZGF0ZSB3aWxsIGJlIGNvbnNpZGVyZWQgYXMgc3RhcnQgZGF0ZVxuLy8gRS5HLiAyMDIwIGJhY2sgdG8gMjAxNyAtLT4gc3RhcnREYXRlOiAyMDE3LCBlbmREYXRlOiAyMDIwXG5mdW5jdGlvbiByZXNvbHZlQW1iaWd1aXR5VGFyZ2V0cyhpbnB1dHM6IERhdGVSYW5nZUNvbnRyb2xJbnRlbnRJbnB1dFtdKTogdm9pZCB7XG5cbiAgICBpZiAoaW5wdXRzWzBdICE9PSB1bmRlZmluZWQgJiYgaW5wdXRzWzFdICE9PSB1bmRlZmluZWQgJiYgaXNOb3RDbGVhclRhcmdldChpbnB1dHNbMF0udGFyZ2V0KSAmJiBpc05vdENsZWFyVGFyZ2V0KGlucHV0c1sxXS50YXJnZXQpKSB7XG4gICAgICAgIGNvbnN0IGRhdGUxOiBEYXRlID0gYWxleGFEYXRlRm9ybWF0VG9EYXRlKGlucHV0c1swXS52YWx1ZSk7XG4gICAgICAgIGNvbnN0IGRhdGUyOiBEYXRlID0gYWxleGFEYXRlRm9ybWF0VG9EYXRlKGlucHV0c1swXS52YWx1ZSk7XG4gICAgICAgIGlmIChkYXRlMSA+IGRhdGUyKSB7XG4gICAgICAgICAgICBpbnB1dHNbMF0udGFyZ2V0ID0gVGFyZ2V0Q2F0ZWdvcnkuRW5kRGF0ZTtcbiAgICAgICAgICAgIGlucHV0c1sxXS50YXJnZXQgPSBUYXJnZXRDYXRlZ29yeS5TdGFydERhdGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbnB1dHNbMF0udGFyZ2V0ID0gVGFyZ2V0Q2F0ZWdvcnkuU3RhcnREYXRlO1xuICAgICAgICAgICAgaW5wdXRzWzFdLnRhcmdldCA9IFRhcmdldENhdGVnb3J5LkVuZERhdGU7XG4gICAgICAgIH1cbiAgICB9XG59Il19