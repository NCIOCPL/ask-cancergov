import { StringOrList } from '../..';
import { ContainerControl, ContainerControlProps, ContainerControlState } from '../../controls/ContainerControl';
import { ControlInput } from '../../controls/ControlInput';
import { ControlResultBuilder } from '../../controls/ControlResult';
import { InteractionModelContributor } from '../../controls/mixins/InteractionModelContributor';
import { ValidationResult } from '../../controls/ValidationResult';
import { ControlInteractionModelGenerator } from '../../interactionModelGeneration/ControlInteractionModelGenerator';
import { ModelData } from '../../interactionModelGeneration/ModelTypes';
import { ControlResponseBuilder } from '../../responseGeneration/ControlResponseBuilder';
import { DateRangeChangedAct, DateRangeSetAct, InvalidValueAct, ValueConfirmedAct, ValueDisconfirmedAct } from "../../systemActs/ContentActs";
import { ConfirmValueAct, RequestValueAct } from '../../systemActs/InitiativeActs';
import { SystemAct } from '../../systemActs/SystemAct';
import { DeepRequired } from '../../utils/DeepRequired';
import { DateControl, DateControlPromptProps, DateValidationFunction } from '../DateControl';
/**
 * Props for a ValueControl.
 */
export interface DateRangeControlProps extends ContainerControlProps {
    /**
     * Unique identifier for control instance
     */
    id: string;
    /**
     * Props for determining if the date(s) are valid.
     */
    validation?: {
        /**
         * Function(s) to determine if the state date (in isolation) is valid.
         *
         * Default: `true`, i.e. any value is valid.
         *
         * Usage:
         * - Validation functions return either `true` or a `ValidationResult`
         *   to describe what validation failed.
         * - Common validation functions for the start-date (in isolation) are
         *   defined in the `DateControlValidations` namespace which can be
         *   added directly to this prop. e.g.:
         * ```
         * valid: DateControlValidations.FUTURE_DATE_ONLY,
         * ```
         */
        startDateValid?: DateValidationFunction | DateValidationFunction[];
        /**
         * Function(s) that determine if the end date (in isolation) is valid.
         *
         * Default: `true`, i.e. any value is valid.
         *
         * Usage:
         * - Validation functions return either `true` or a `ValidationResult`
         *   to describe what validation failed.
         * - Common validation functions for the end-date (in isolation) are
         *   defined in the `DateControlValidations` namespace which can be
         *   added directly to this prop. e.g.:
         * ```
         * valid: DateControlValidations.FUTURE_DATE_ONLY,
         * ```
         */
        endDateValid?: DateValidationFunction | DateValidationFunction[];
        /**
         * Function(s) that determine if the date-range is valid.
         *
         * Default: `true`, i.e. any value is valid.
         *
         * Usage:
         * - Validation functions return either `true` or a `ValidationResult`
         *   to describe what validation failed.
         * - Common validation functions for the "date range" are defined in the
         *   `DateRangeControlValidations` namespace which can be added directly
         *   to this prop. e.g.:
         * ```
         * valid: DateRangeControlValidations.START_BEFORE_END,
         * ```
         */
        rangeValid?: DateRangeValidationFunction | DateRangeValidationFunction[];
    };
    /**
     * Determines if the Control must obtain a value.
     *
     * If `true`:
     *  - the Control report isReady() = false if no value has been obtained.
     *  - the control will take the initiative when given the opportunity.
     */
    required?: boolean | ((input: ControlInput) => boolean);
    /**
     * Whether the Control has to obtain explicit confirmation of the value.
     *
     * If `true`:
     *  - the Control will report `isReady() = false` if the value has not been
     *    explicitly confirmed as correct by user.
     *  - the Control will take the initiative when given the opportunity.
     */
    confirmationRequired?: boolean | ((input: ControlInput) => boolean);
    /**
     * Props to customize the prompt fragments that will be added by
     * `this.renderAct()`.
     */
    prompts?: DateRangeControlPromptProps;
    /**
     * Props to customize the reprompt fragments that will be added by
     * `this.renderAct()`.
     */
    reprompts?: DateRangeControlPromptProps;
    /**
     * Props to customize the relationship between the control and the
     * interaction model.
     */
    interactionModel?: DateRangeControlInteractionModelProps;
}
/**
 * Date range validation function
 */
export declare type DateRangeValidationFunction = ((state: DateRangeControlState, input: ControlInput) => true | ValidationResult);
/**
 * Mapping of action slot values to the behaviors that this control supports.
 *
 * Behavior:
 * - This control will not handle an input if the action-slot is filled with an
 *   value whose ID is not associated with a capability.
 */
export interface DateRangeControlActionProps {
    /**
     * Action slot value IDs that are associated with the "set value" capability.
     *
     * Default: ['builtin_set']
     */
    set?: string[];
    /**
     * Action slot value IDs that are associated with the "change value" capability.
     *
     * Default ['builtin_change']
     */
    change?: string[];
}
/**
 * Props associated with the interaction model.
 */
export interface DateRangeControlInteractionModelProps {
    /**
     * Target-slot values associated with this Control.
     *
     * Specific targets can be specified for the start-date, the end-date and
     * the range as a whole.
     */
    targets?: DateRangeControlTargetProps;
    /**
     * Action slot-values associated to the control's capabilities.
     *
     * Action slot-values associate utterances to a control. For example, if the
     * user says "change the time", it is parsed as a `GeneralControlIntent`
     * with slot values `action = change` and `target = time`.  Only controls
     * that are registered with the `change` action should offer to handle this
     * intent.
     *
     * Usage:
     *  - This allows users to refer to an action using more domain-appropriate
     *    words. For example, a user might like to say 'show two items' rather
     *    that 'set item count to two'.  To achieve this, include the
     *    slot-value-id 'show' in the list associated with the 'set' capability
     *    and ensure the interaction-model includes an action slot value with
     *    id=show and appropriate synonyms.
     *  - The 'builtin_*' IDs are associated with default interaction model data
     *    (which can be extended as desired). Any other IDs will require a full
     *    definition of the allowed synonyms in the interaction model.
     */
    actions?: DateRangeControlActionProps;
}
export declare type DateRangeControlTargetProps = {
    /**
     * Target-slot values associated with the control as a whole, i.e. the date
     * range.
     *
     * Targets associate utterances to a control. For example, if the user says
     * "change the time", it is parsed as a `GeneralControlIntent` with slot
     * values `action = change` and `target = time`.  Only controls that are
     * registered with the `time` target should offer to handle this intent.
     *
     * Default: ['builtin_date_range', 'builtin_date', 'builtin_it']
     *
     * Usage:
     * - If this prop is defined, it replaces the default; it is not additive
     *   the defaults.  To add an additional target to the defaults, copy the
     *   defaults and amend.
     * - A control can be associated with many target-slot-values, eg ['date',
     *   'startDate', 'eventStartDate', 'vacationStart']
     * - It is a good idea to associate with general targets (e.g. date) and
     *   also with specific targets (e.g. vacationStart) so that the user can
     *   say either general or specific things.  e.g. 'change the date to
     *   Tuesday', or 'I want my vacation to start on Tuesday'.
     * - The association does not have to be exclusive, and general target slot
     *   values will often be associated with many controls. In situations where
     *   there is ambiguity about what the user is referring to, the parent
     *   controls must resolve the confusion.
     * - The 'builtin_*' IDs are associated with default interaction model data
     *   (which can be extended as desired). Any other IDs will require a full
     *   definition of the allowed synonyms in the interaction model.
     *
     * Control behavior:
     * - A control will not handle an input that mentions a target that is not
     *   registered by this prop.
     */
    self?: string[];
    /**
     * Target-slot values associated with the start date in isolation.
     *
     * Targets associate utterances to a control. For example, if the user says
     * "change the time", it is parsed as a `GeneralControlIntent` with slot
     * values `action = change` and `target = time`.  Only controls that are
     * registered with the `time` target should offer to handle this intent.
     *
     * Default: ['builtin_start_date', 'builtin_date', 'builtin_it']
     *
     * Usage:
     * - If this prop is defined, it replaces the default; it is not additive
     *   the defaults.  To add an additional target to the defaults, copy the
     *   defaults and amend.
     * - A control can be associated with many target-slot-values, eg ['date',
     *   'startDate', 'eventStartDate', 'vacationStart']
     * - It is a good idea to associate with general targets (e.g. date) and
     *   also with specific targets (e.g. vacationStart) so that the user can
     *   say either general or specific things.  e.g. 'change the date to
     *   Tuesday', or 'I want my vacation to start on Tuesday'.
     * - The association does not have to be exclusive, and general target slot
     *   values will often be associated with many controls. In situations where
     *   there is ambiguity about what the user is referring to, the parent
     *   controls must resolve the confusion.
     * - The 'builtin_*' IDs are associated with default interaction model data
     *   (which can be extended as desired). Any other IDs will require a full
     *   definition of the allowed synonyms in the interaction model.
     *
     * Control behavior:
     * - A control will not handle an input that mentions a target that is not
     *   registered by this prop.
     */
    startDate?: string[];
    /**
     * Target-slot values associated with the end date in isolation.
     *
     * Targets associate utterances to a control. For example, if the user says
     * "change the time", it is parsed as a `GeneralControlIntent` with slot
     * values `action = change` and `target = time`.  Only controls that are
     * registered with the `time` target should offer to handle this intent.
     *
     * Default: ['builtin_end_date', 'builtin_date', 'builtin_it']
     *
     * Usage:
     * - If this prop is defined, it replaces the default; it is not additive
     *   the defaults.  To add an additional target to the defaults, copy the
     *   defaults and amend.
     * - A control can be associated with many target-slot-values, eg ['date',
     *   'startDate', 'eventStartDate', 'vacationStart']
     * - It is a good idea to associate with general targets (e.g. date) and
     *   also with specific targets (e.g. vacationStart) so that the user can
     *   say either general or specific things.  e.g. 'change the date to
     *   Tuesday', or 'I want my vacation to start on Tuesday'.
     * - The association does not have to be exclusive, and general target slot
     *   values will often be associated with many controls. In situations where
     *   there is ambiguity about what the user is referring to, the parent
     *   controls must resolve the confusion.
     * - The 'builtin_*' IDs are associated with default interaction model data
     *   (which can be extended as desired). Any other IDs will require a full
     *   definition of the allowed synonyms in the interaction model.
     *
     * Control behavior:
     * - A control will not handle an input that mentions a target that is not
     *   registered by this prop.
     */
    endDate?: string[];
};
/**
 * Reason codes for built-in validation rules.
 */
export declare enum DateRangeValidationFailReasonCode {
    /**
     * The start date must precede the end date.
     */
    START_BEFORE_END = "startBeforeEnd"
}
/**
 * Built-in validation functions for use with DateControl
 */
export declare namespace DateRangeControlValidations {
    const START_BEFORE_END: DateRangeValidationFunction;
}
/**
 * Props to customize the prompt fragments that will be added by
 * `this.renderAct()`.
 */
export interface DateRangeControlPromptProps {
    startDate?: DateControlPromptProps;
    endDate?: DateControlPromptProps;
    requestValue?: StringOrList | ((act: RequestValueAct, input: ControlInput) => StringOrList);
    valueSet?: StringOrList | ((act: DateRangeSetAct, input: ControlInput) => StringOrList);
    valueChanged?: StringOrList | ((act: DateRangeChangedAct, input: ControlInput) => StringOrList);
    invalidValue?: StringOrList | ((act: InvalidValueAct<string>, input: ControlInput) => StringOrList);
    valueDisaffirmed?: StringOrList | ((act: ValueDisconfirmedAct<string>, input: ControlInput) => StringOrList);
    valueAffirmed?: StringOrList | ((act: ValueConfirmedAct<string>, input: ControlInput) => StringOrList);
    confirmValue?: StringOrList | ((act: ConfirmValueAct<string>, input: ControlInput) => StringOrList);
}
/**
 * State tracked by a DateRangeControl.
 */
export declare class DateRangeControlState extends ContainerControlState {
    /**
     * The start date
     */
    startDate?: string;
    /**
     * The end date
     */
    endDate?: string;
    /**
     * The previous start date
     */
    previousStartDate?: string;
    /**
     * The previous end date
     */
    previousEndDate?: string;
    /**
     * Tracks whether the dateRangeControl is requesting a change to the whole range.
     */
    isChangingRange: boolean;
    /**
     * Tracks whether the dateRangeControl is confirming the whole range.
     */
    isConfirmingRange: boolean;
    /**
     * Tracks whether the topic of conversation is the whole range.
     */
    onFocus: boolean;
    /**
     * Tracks whether the range has been explicitly confirmed by the user.
     */
    isValueConfirmed: boolean;
}
/**
 * Categorization of "what seems to be the target" of a utterance.
 */
export declare enum TargetCategory {
    StartDate = "startDate",
    EndDate = "endDate",
    Both = "both",
    Neither = "neither",
    Either = "either"
}
/**
 * Categorization of "what seems to be the target" of a utterance.
 */
export declare enum DateControlTarget {
    StartDate = "startDate",
    EndDate = "endDate"
}
/**
 * A Control that obtains a date range from the user.
 *
 * Capabilities:
 * - Request a range, or just the start/end date
 * - Change the range, or just the start/end date
 * - Validate the range or just the start/end date
 * - Confirm the range or just the start/end date
 * - Infer specific date(s) for a partially specified date(s).
 *
 * Intents that can be handled:
 * - `GeneralControlIntent`: E.g. `"yes, update my birth date"`
 * - `ConjunctionControlIntent`: E.g. `"yes, change the start and end dates"`
 * - `DateRangeControlIntent`: E.g. "no Tuesday to Saturday".
 * - `AMAZON_DATE_ValueControlIntent`: E.g. "no change it to Tuesday".
 * - `AMAZON.YesIntent`, `AMAZON.NoIntent`
 */
export declare class DateRangeControl extends ContainerControl implements InteractionModelContributor {
    state: DateRangeControlState;
    children: DateControl[];
    props: DeepRequired<DateRangeControlProps>;
    private startDateControl;
    private endDateControl;
    private handleFunc;
    private takeInitiativeFunc;
    static mergeWithDefaultProps(props: DateRangeControlProps): DeepRequired<DateRangeControlProps>;
    constructor(props: DateRangeControlProps);
    canHandle(input: ControlInput): Promise<boolean>;
    handle(input: ControlInput, resultBuilder: ControlResultBuilder): Promise<void>;
    updateInteractionModel(generator: ControlInteractionModelGenerator, imData: ModelData): void;
    getTargetIds(): string[];
    private getStartDateFromChild;
    private getEndDateFromChild;
    private setStartDate;
    private setEndDate;
    private canHandleForFocus;
    private canHandleForNoFocus;
    /**
     * Test if the input has both start date and end date provided
     */
    private isTwoValueInput;
    private handleTwoValueInput;
    /**
     * Determine whether the input single date value should be considered as date range
     *
     * The DateRangeControl will regard a single value input as date range when there's no clear target and
     * when the DateRangeControl itself is under focus
     * E.G. 'set range to 2018', where 2018 will be regarded as a range and both start date and end date will be set to 2018
     */
    private isDateInterpretedAsDateRange;
    private handleDateRangeInput;
    /**
     * Determine whether the input action is targeting both start date and end date
     *
     * E.G. 'Change start date and end date'
     */
    private isChangeBoth;
    /**
     * Determine whether the input action is targeting date range
     *
     * E.G. 'Change', 'Change date'
     */
    private isChangeRange;
    private isConfirmationAffirmed;
    private handleConfirmationAffirmed;
    private isConfirmationDisAffirmed;
    private handleConfirmationDisAffirmed;
    private handleChangeValue;
    private updatePrior;
    private ackDateRangeValueChanged;
    private validateDateRange;
    renderAct(act: SystemAct, input: ControlInput, builder: ControlResponseBuilder): void;
    canTakeInitiative(input: ControlInput): Promise<boolean>;
    takeInitiative(input: ControlInput, resultBuilder: ControlResultBuilder): Promise<void>;
    private needsValue;
    private requestDateRange;
    private isChangingRange;
    private wantsToCorrectRange;
    private correctRange;
    private wantsToConfirmRange;
    private confirmValue;
    canTakeInitiativeByChild(input: ControlInput): Promise<boolean>;
}
//# sourceMappingURL=DateRangeControl.d.ts.map