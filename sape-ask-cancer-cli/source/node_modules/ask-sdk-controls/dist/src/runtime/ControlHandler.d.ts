import { HandlerInput, RequestHandler } from "ask-sdk-core";
import { Response } from "ask-sdk-model";
import { IControl } from '../controls/interfaces/IControl';
import { IControlInput } from '../controls/interfaces/IControlInput';
import { IControlManager } from '../controls/interfaces/IControlManager';
import { IControlResultBuilder } from '../controls/interfaces/IControlResultBuilder';
/**
 * Extended Response, surfacing additional information
 */
export interface IControlResponse extends Response {
    isTurnEnding: boolean;
}
/**
 * RequestHandler for a skill built using Controls.
 *
 * This is the common runtime that drives the processing flow for a skill that
 * uses Controls.  Please see the user guide for a thorough discussion of the
 * phases of processing and how the common `ControlHandler` interfaces with
 * an instance of `ControlManager` and the control tree.
 *
 */
export declare class ControlHandler implements RequestHandler {
    static attributeNameState: string;
    static attributeNameContext: string;
    controlManager: IControlManager;
    rootControl?: IControl;
    private additionalSessionContext;
    private controlInput;
    private preparedRequestId;
    /**
     * Determines if the controls state will be correctly reestablished on the
     * next turn
     *
     * Usage:
     *  * If a skill uses more than one ControlHandler the state validation
     *    procedure gets confused due to unexpected control states in session
     *    attributes. In this situation, set `validateStateRoundtrip = false`.
     */
    validateStateRoundtrip: boolean;
    constructor(controlManager: IControlManager);
    private prepare;
    private getStateMapFromSessionAttributes;
    private static createControlMap;
    /**
     * Determines if this RequestHandler handle the input.
     *
     * @param handlerInput - HandlerInput
     */
    canHandle(handlerInput: HandlerInput): Promise<boolean>;
    /**
     * Handle the input.
     *
     * @param handlerInput - HandlerInput
     */
    handle(handlerInput: HandlerInput, processInput?: boolean): Promise<IControlResponse>;
    /**
     * Creates a string 'C:<nControls>' for inclusion in UserAgent to indicate usage.
     *
     * The information gathered is only the number of Controls being used.
     * This will help the dev team to understand usage - thank you!
     */
    userAgentInfo(): string;
    /**
     * Implements the core of the processing loop
     *
     * Public for testing
     */
    static handleCore(rootControl: IControl, input: IControlInput, resultBuilder: IControlResultBuilder, handleInput?: boolean): Promise<void>;
    private static initiativePhase;
    /**
     * Take the initiative in the dialog.
     *
     * Any existing content in the Response's prompt & reprompt is overwritten.
     * To avoid losing this content, pass it in using parameters promptPrefix &
     * repromptPrefix.
     *
     * Usage:
     *  * This method is used to transition from a regular `RequestHandler` into
     *    Controls For example, when a regular `RequestHandler` consumes the
     *    input but doesn't want to keep the initiative, it can ask a
     *    ControlHandler to take the initiative to complete the turn.  A
     *    prompt/reprompt fragment can be specified by the `RequestHandler`
     *    which will be included as the start of the overall prompt/reprompt.
     *
     * @param handlerInput - Handler input
     * @param promptPrefix - Prompt fragment to prefix the prompt generated via
     * Controls.
     * @param repromptPrefix - Reprompt fragment to prefix to the prompt
     * generated via Controls
     */
    takeInitiative(handlerInput: HandlerInput, promptPrefix: string, repromptPrefix?: string): Promise<IControlResponse>;
    static getPromptAndRepromptFromResponse(response: IControlResponse): [string, string];
    private buildResponseCore;
    getSerializableControlStates(): {
        [key: string]: any;
    };
}
/**
 * Visits each control in the tree and attaches the corresponding state object.
 *
 * @param control - Control
 * @param state - Map of state data to attach to the controls
 */
export declare function attachStateToControlTree(control: IControl, state: {
    [key: string]: any;
}): void;
/**
 * Visits each controls and collates the state objects.
 *
 * @param rootControl - Root control
 */
export declare function extractStateFromControlTree(rootControl: IControl): {
    [key: string]: any;
};
//# sourceMappingURL=ControlHandler.d.ts.map