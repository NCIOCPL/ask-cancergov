import { Control, ControlProps, ControlState } from './Control';
import { ControlInput } from './ControlInput';
import { ControlResultBuilder } from './ControlResult';
import { IContainerControl } from './interfaces/IContainerControl';
import { ControlStateDiagramming } from './mixins/ControlStateDiagramming';
/**
 * Records the turn that a child control did something of interest.
 */
interface ChildActivityRecord {
    controlId: string;
    turnNumber: number;
}
/**
 * Container state for use in arbitration
 */
export declare class ContainerControlState implements ControlState {
    value?: any;
    lastHandlingControl?: ChildActivityRecord;
    lastInitiativeChild?: ChildActivityRecord;
}
export declare class ContainerControlProps implements ControlProps {
    id: string;
}
export declare class ContainerControlCompleteProps implements ControlProps {
    id: string;
}
/**
 *  A control that uses and manages child controls.
 *
 *  Default logic of `decideHandlingChild()` & `decideInitiativeChild()`:
 *   1. Choose the most-recent initiative control if is a candidate.
 *   2. Otherwise, choose the first candidate in the positional order of the
 *      `this.children` array.
 *   3. In the special case of `input = FallbackIntent`, only the most-recent
 *      initiative control is considered. If it is not a candidate, then no
 *      child is selected.
 *
 *  Usage:
 *  - Container controls can and should add high-level behaviors and respond to
 *    high-level requests such as multi-valued intents.
 *
 *  - Container controls should forward simple inputs to the child controls
 *    whenever possible in order to share the load and achieve scalable logic.
 *
 *  - Container controls should explicitly decide which child will handle an
 *    input or take the initiative in situations where there are multiple
 *    children that respond `canHandle = true` or `canTakeInitiative = true`.
 *
 */
export declare class ContainerControl extends Control implements IContainerControl, ControlStateDiagramming {
    state: ContainerControlState;
    children: Control[];
    rawProps: ContainerControlProps;
    props: ContainerControlCompleteProps;
    selectedHandlingChild: Control | undefined;
    selectedInitiativeChild: Control | undefined;
    constructor(props: ContainerControlProps);
    static mergeWithDefaultProps(props: ContainerControlProps): any;
    /**
     * Add a control as a child.
     *
     * @param control - Control
     * @returns the container
     */
    addChild(control: Control): this;
    canHandle(input: ControlInput): Promise<boolean>;
    handle(input: ControlInput, resultBuilder: ControlResultBuilder): Promise<void>;
    canTakeInitiative(input: ControlInput): Promise<boolean>;
    takeInitiative(input: ControlInput, resultBuilder: ControlResultBuilder): Promise<void>;
    stringifyStateForDiagram(): string;
    /**
     * Determines if a child control can handle the request.
     *
     * From the candidates that report `canHandle = true`, a winner is selected
     * by `this.decideHandlingChild(candidates)`.
     *
     * The selected "winner" is recorded in `this.selectedHandlingChild`.
     *
     * @param input - Input
     */
    canHandleByChild(input: ControlInput): Promise<boolean>;
    /**
     * Delegates handling of the request to the child control selected during
     * canHandleByChild.
     *
     * @param input - Input
     * @param resultBuilder - Response builder.
     */
    handleByChild(input: ControlInput, resultBuilder: ControlResultBuilder): Promise<void>;
    /**
     * Calls canHandle on each child control to determine the candidates for
     * delegation.
     * @param input - Input
     */
    gatherHandlingCandidates(input: ControlInput): Promise<Control[]>;
    /**
     * Decides a winner from the canHandle candidates.
     *
     * The candidates should be all the child controls for which
     * `canHandle(input) = true`
     *
     * Default logic:
     *  1. Choose the  most-recent initiative control if is a candidate.
     *  2. Otherwise, choose the first candidate in the positional order of the
     *     `this.children` array.
     *  3. In the special case of input===FallbackIntent, only the most-recent
     *     initiative control is considered. If it is not a candidate, then no
     *     child is selected and this method returns undefined.
     *
     * Remarks:
     *  * The special case for FallbackIntent exists because that intent is not
     *    user-initiative -- rather it indicates a failure to understanding the
     *    user.  In cases of misunderstanding, only active controls should be
     *    considered.
     *
     * @param candidates - The child controls that reported `canHandle = true`
     * @param input - Input
     */
    decideHandlingChild(candidates: Control[], input: ControlInput): Promise<Control | undefined>;
    /**
     * Determines if a child control can take the initiative.
     *
     * From the candidates that report `canTakeInitiative = true`, a winner is selected
     * by `this.decideInitiativeChild(candidates)`.
     *
     * The selected "winner" is recorded in `this.selectedInitiativeChild`.
     *
     * @param input - Input
     */
    canTakeInitiativeByChild(input: ControlInput): Promise<boolean>;
    /**
     * Delegates initiative generation to the child control selected during
     * canHandleByChild.
     *
     * @param input - Input
     * @param resultBuilder - Response builder.
     */
    takeInitiativeByChild(input: ControlInput, resultBuilder: ControlResultBuilder): Promise<void>;
    /**
     * Calls canTakeInitiative on each child control to determine the candidates
     * for delegation.
     * @param input - Input
     */
    gatherInitiativeCandidates(input: ControlInput): Promise<Control[]>;
    /**
     * Decide a winner from the canTakeInitiative candidates.
     *
     * The eligible candidates are child controls for which
     * `canTakeInitiative(input) = true`.
     *
     * Default logic:
     *  1. choose the most-recent initiative control if is a candidate.
     *  2. otherwise choose the first candidate in the positional order of the
     *     `this.children` array.
     *
     * @param candidates - The child controls that reported `canTakeInitiative = true`
     * @param input - Input
     */
    decideInitiativeChild(candidates: Control[], input: ControlInput): Promise<Control | undefined>;
}
/**
 * Returns the control with `id = childID` if it exists
 *
 * @param controls - Controls
 * @param childId - The id to match
 */
export declare function tryGetForId(controls: Control[], childId?: string): Control | undefined;
export {};
//# sourceMappingURL=ContainerControl.d.ts.map