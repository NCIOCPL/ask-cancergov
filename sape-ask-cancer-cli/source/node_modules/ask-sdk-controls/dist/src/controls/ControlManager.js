"use strict";
/*
 * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.updateIMForControlTree = exports.renderActsInSequence = exports.ControlManager = void 0;
const tslib_1 = require("tslib");
const i18next_1 = tslib_1.__importDefault(require("i18next"));
const lodash_1 = tslib_1.__importDefault(require("lodash"));
const LanguageStrings_1 = require("../commonControls/LanguageStrings");
const Control_1 = require("../controls/Control");
const InteractionModelContributor_1 = require("../controls/mixins/InteractionModelContributor");
const ControlInteractionModelGenerator_1 = require("../interactionModelGeneration/ControlInteractionModelGenerator");
const Logger_1 = require("../logging/Logger");
const IContainerControl_1 = require("./interfaces/IContainerControl");
const log = new Logger_1.Logger('AskSdkControls:ControlManager');
/**
 * Defines the high-level functionality for a skill built with Controls.
 *
 * Each skill that uses controls should define a concrete sub-class that
 * implements `createControlTree` and optionally overrides other methods.
 *
 * Summary:
 *  * createControlTree() creates a hierarchy of controls that cooperatively
 *    manage the skill behavior.
 *   * The methods on the root control will be called to process the user's
 *     input and to generate system initiative.
 *
 *  * render() is the entry-point for the render-phase.
 *   * High-level overrides and multi-act rendering should be performed by
 *     `controlManager.render()`. The default is to render each act one-by-one
 *     by calling `control.renderAct(act)`.  This builds up a result by
 *     concatenation of response fragments which is sufficient in many cases.
 *
 *  * The `ControlResult` contains a list of SystemActs that describe *what*
 *    should be communicated to the user but generally should not describe *how*
 *    to present it.
 *
 *  * `handleInternalError` provides an entry-point for custom handling of
 *    internal errors.
 *
 *  * `buildInteractionModel` provides an entry-point for building the
 *    Control-specific aspects of skill's Interaction Model.
 *
 * Internationalization and Localization
 *  * Controls themselves are location-agnostic.  They consume abstract inputs
 *    (Intents, etc) and produce abstract outputs (SystemActs)
 *
 *  * Mapping localized input to abstract inputs is the role of NLU and the
 *    necessary information is stored in the Interaction Model.
 *   * The ControlManager props includes a bag of localization data that is used
 *     during interaction-model building for a given locale.
 *   * The framework ships with a default set of interaction model data for
 *     en-US.
 *
 *  * Mapping abstract output to physical output (prompts, APL strings) etc is
 *    the role of the rendering phase.  This information is part of the skill
 *    definition but can be located in various places: either in a monolithic
 *    render() function, or scattered around the various Controls and Acts.
 */
class ControlManager {
    /**
     * Creates an instance of a Control Manager.
     * @param props - props
     */
    constructor(props) {
        this.props = ControlManager.mergeWithDefaultProps(props);
        const resource = lodash_1.default.merge(LanguageStrings_1.systemResource, this.props.i18nResources);
        i18nInit(this.props.locale, resource);
    }
    static mergeWithDefaultProps(props) {
        const defaults = {
            locale: 'en-US',
            i18nResources: {}
        };
        return lodash_1.default.mergeWith(defaults, props);
    }
    /**
     * Transforms the information in ControlResult into user-facing content
     * (prompts and APL).
     *
     * Default: The default rendering strategy renders each `SystemAct` in turn
     *          by calling `act.control.render(act)`. This strategy leads to
     *          prompts that are a concatenation of the prompt-fragment for each
     *          `SystemAct`.
     *
     * Usage:
     *  * In many situations rendering the acts one-by-one is sufficient as the
     *    concatenation of prompt fragments leads to usable prompts.  For
     *    example
     *
     * ```js
     *    [ValueSetAct(ageCtrl, 5), RequestValueAct(nameCtrl)]
     * ```
     *    may be rendered sequentially to produce:
     *
     * ```js
     *    -> 'OK, 5. What is your name?"
     * ```
     *
     *    * For more complex situations, override this method and implement a
     *      custom rendering strategy.  Often the solution will be to implement
     *      some special cases and otherwise fallback to the default by calling
     *      super.render() or by directly calling
     *      `ControlManager.renderActsOneByOne()`.
     *
     */
    render(result, input, controlResponseBuilder) {
        renderActsInSequence(result.acts, input, controlResponseBuilder);
    }
    /**
     * Handles an internal error.
     *
     * This is intended for logging, reporting and perhaps mentioning the
     * situation to the user. The user session will be automatically closed.
     *
     * Default: The error object is converted into an object with enumerable
     * properties and logged at logLevel=error
     * @param input - Input
     * @param error - Error
     * @param responseBuilder - Response builder
     */
    handleInternalError(input, error, responseBuilder) {
        const err = error.stack !== undefined ? { name: error.name, msg: error.message, stack: error.stack } : error; // Error doesn't have enumerable properties, so we convert it.
        log.error(`Error handled: ${JSON.stringify(err)}`);
    }
    /**
     * Builds interaction model content required by the Control tree.
     *
     * Usage:
     * - The imDataMap has 'en-US' modelData registered by default
     * - The developer may configure and register additional `imDataMap`
     *   instances to support additional locales
     *
     * * If imDataMap doesn't have data for the requested locale a
     *   `LocaleNotSupportedError` will be thrown
     *
     * @param generator - Interaction Model Generator
     */
    buildInteractionModel(generator) {
        const rootControl = this.createControlTree({});
        const imData = ControlInteractionModelGenerator_1.generateModelData();
        updateIMForControlTree(generator, rootControl, imData);
    }
}
exports.ControlManager = ControlManager;
/**
 * Render each of the acts, one-by-one.
 *
 *
 * @param systemActs - The system acts to render
 * @param input - Input
 * @param responseBuilder - Response builder.
 */
function renderActsInSequence(systemActs, input, controlResponseBuilder) {
    for (const act of systemActs) {
        act.control.renderAct(act, input, controlResponseBuilder);
    }
}
exports.renderActsInSequence = renderActsInSequence;
/**
 * Visits every control in the tree and updates the interaction model for each
 * control. Go through the entire control tree and update IM
 * @param generator - Interaction model generator
 * @param control - Root control
 * @param imData - Localized data for use in interaction model
 */
// TODO: param-ordering
function updateIMForControlTree(generator, control, imData) {
    if (control instanceof Control_1.Control && InteractionModelContributor_1.implementsInteractionModelContributor(control)) {
        control.updateInteractionModel(generator, imData);
        const targetIds = control.getTargetIds();
        if (targetIds !== undefined) {
            targetIds.forEach((targetId) => {
                generator.targetSlotIds = generator.targetSlotIds.add(targetId);
            });
        }
    }
    // If container control, do same thing recursively
    if (IContainerControl_1.isContainerControl(control)) {
        for (const child of control.children) {
            updateIMForControlTree(generator, child, imData);
        }
    }
}
exports.updateIMForControlTree = updateIMForControlTree;
/**
 * Initializes the internationalization system (i18next).
 *
 * This loads data for the specified local from the resources.
 *
 * @param locale - The locale to specialize to.
 * @param resources - Resources for all supported locales.
 */
function i18nInit(locale, resources) {
    if (!locale) {
        throw new Error('Please specify the language.');
    }
    void i18next_1.default.init({
        lng: locale,
        resources,
        fallbackLng: 'en',
    });
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ29udHJvbE1hbmFnZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvY29udHJvbHMvQ29udHJvbE1hbmFnZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBOzs7Ozs7Ozs7OztHQVdHOzs7O0FBR0gsOERBQTRDO0FBQzVDLDREQUF1QjtBQUN2Qix1RUFBbUU7QUFDbkUsaURBQThDO0FBQzlDLGdHQUF1RztBQUN2RyxxSEFBcUk7QUFFckksOENBQTJDO0FBSzNDLHNFQUFvRTtBQUlwRSxNQUFNLEdBQUcsR0FBRyxJQUFJLGVBQU0sQ0FBQywrQkFBK0IsQ0FBQyxDQUFDO0FBVXhEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBMkNHO0FBQ0gsTUFBc0IsY0FBYztJQWFoQzs7O09BR0c7SUFDSCxZQUFZLEtBQTJCO1FBQ25DLElBQUksQ0FBQyxLQUFLLEdBQUcsY0FBYyxDQUFDLHFCQUFxQixDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQ3pELE1BQU0sUUFBUSxHQUFhLGdCQUFDLENBQUMsS0FBSyxDQUFDLGdDQUFjLEVBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxhQUFhLENBQUMsQ0FBQztRQUM3RSxRQUFRLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLEVBQUUsUUFBUSxDQUFDLENBQUM7SUFDMUMsQ0FBQztJQWpCRCxNQUFNLENBQUMscUJBQXFCLENBQUMsS0FBc0M7UUFDL0QsTUFBTSxRQUFRLEdBQWtDO1lBQzVDLE1BQU0sRUFBRSxPQUFPO1lBQ2YsYUFBYSxFQUFFLEVBQUU7U0FDcEIsQ0FBQztRQUVGLE9BQU8sZ0JBQUMsQ0FBQyxTQUFTLENBQUMsUUFBUSxFQUFFLEtBQUssQ0FBQyxDQUFDO0lBQ3hDLENBQUM7SUFvQ0Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BNkJHO0lBQ0gsTUFBTSxDQUFDLE1BQXFCLEVBQUUsS0FBbUIsRUFBRSxzQkFBOEM7UUFDN0Ysb0JBQW9CLENBQUMsTUFBTSxDQUFDLElBQUksRUFBRSxLQUFLLEVBQUUsc0JBQXNCLENBQUMsQ0FBQztJQUNyRSxDQUFDO0lBRUQ7Ozs7Ozs7Ozs7O09BV0c7SUFDSCxtQkFBbUIsQ0FBQyxLQUFtQixFQUFFLEtBQVUsRUFBRSxlQUFnQztRQUNqRixNQUFNLEdBQUcsR0FBRyxLQUFLLENBQUMsS0FBSyxLQUFLLFNBQVMsQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLEVBQUUsS0FBSyxDQUFDLElBQUksRUFBRSxHQUFHLEVBQUUsS0FBSyxDQUFDLE9BQU8sRUFBRSxLQUFLLEVBQUUsS0FBSyxDQUFDLEtBQUssRUFBRSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyw4REFBOEQ7UUFDNUssR0FBRyxDQUFDLEtBQUssQ0FBQyxrQkFBa0IsSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUM7SUFDdkQsQ0FBQztJQUVEOzs7Ozs7Ozs7Ozs7T0FZRztJQUNILHFCQUFxQixDQUFDLFNBQTJDO1FBQzdELE1BQU0sV0FBVyxHQUFHLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxFQUFFLENBQUMsQ0FBQztRQUMvQyxNQUFNLE1BQU0sR0FBYyxvREFBaUIsRUFBRSxDQUFDO1FBQzlDLHNCQUFzQixDQUFDLFNBQVMsRUFBRSxXQUFXLEVBQUUsTUFBTSxDQUFDLENBQUM7SUFDM0QsQ0FBQztDQUNKO0FBcEhELHdDQW9IQztBQUVEOzs7Ozs7O0dBT0c7QUFDSCxTQUFnQixvQkFBb0IsQ0FBQyxVQUF1QixFQUFFLEtBQW1CLEVBQUUsc0JBQThDO0lBQzdILEtBQUssTUFBTSxHQUFHLElBQUksVUFBVSxFQUFFO1FBQzFCLEdBQUcsQ0FBQyxPQUFPLENBQUMsU0FBUyxDQUFDLEdBQUcsRUFBRSxLQUFLLEVBQUUsc0JBQXNCLENBQUMsQ0FBQztLQUM3RDtBQUNMLENBQUM7QUFKRCxvREFJQztBQUVEOzs7Ozs7R0FNRztBQUNILHVCQUF1QjtBQUN2QixTQUFnQixzQkFBc0IsQ0FBQyxTQUEyQyxFQUFFLE9BQWlCLEVBQUUsTUFBaUI7SUFDcEgsSUFBSSxPQUFPLFlBQVksaUJBQU8sSUFBSSxtRUFBcUMsQ0FBQyxPQUFPLENBQUMsRUFBRTtRQUM5RSxPQUFPLENBQUMsc0JBQXNCLENBQUMsU0FBUyxFQUFFLE1BQU0sQ0FBQyxDQUFDO1FBQ2xELE1BQU0sU0FBUyxHQUF5QixPQUFPLENBQUMsWUFBWSxFQUFFLENBQUM7UUFDL0QsSUFBSSxTQUFTLEtBQUssU0FBUyxFQUFFO1lBQ3pCLFNBQVMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxRQUFRLEVBQUUsRUFBRTtnQkFDM0IsU0FBUyxDQUFDLGFBQWEsR0FBRyxTQUFTLENBQUMsYUFBYSxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsQ0FBQztZQUNwRSxDQUFDLENBQUMsQ0FBQztTQUNOO0tBQ0o7SUFFRCxrREFBa0Q7SUFDbEQsSUFBSSxzQ0FBa0IsQ0FBQyxPQUFPLENBQUMsRUFBRTtRQUM3QixLQUFLLE1BQU0sS0FBSyxJQUFJLE9BQU8sQ0FBQyxRQUFRLEVBQUU7WUFDbEMsc0JBQXNCLENBQUMsU0FBUyxFQUFFLEtBQUssRUFBRSxNQUFNLENBQUMsQ0FBQztTQUNwRDtLQUNKO0FBQ0wsQ0FBQztBQWpCRCx3REFpQkM7QUFFRDs7Ozs7OztHQU9HO0FBQ0gsU0FBUyxRQUFRLENBQUMsTUFBYyxFQUFFLFNBQW1CO0lBQ2pELElBQUksQ0FBQyxNQUFNLEVBQUU7UUFDVCxNQUFNLElBQUksS0FBSyxDQUFDLDhCQUE4QixDQUFDLENBQUM7S0FDbkQ7SUFDRCxLQUFLLGlCQUFPLENBQUMsSUFBSSxDQUFDO1FBQ2QsR0FBRyxFQUFFLE1BQU07UUFDWCxTQUFTO1FBQ1QsV0FBVyxFQUFFLElBQUk7S0FDcEIsQ0FBQyxDQUFDO0FBQ1AsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBbWF6b24uY29tLCBJbmMuIG9yIGl0cyBhZmZpbGlhdGVzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKS5cbiAqIFlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIEEgY29weSBvZiB0aGUgTGljZW5zZSBpcyBsb2NhdGVkIGF0XG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIG9yIGluIHRoZSBcImxpY2Vuc2VcIiBmaWxlIGFjY29tcGFueWluZyB0aGlzIGZpbGUuIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZFxuICogb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyXG4gKiBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZ1xuICogcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IFJlc3BvbnNlQnVpbGRlciB9IGZyb20gJ2Fzay1zZGstY29yZSc7XG5pbXBvcnQgaTE4bmV4dCwgeyBSZXNvdXJjZSB9IGZyb20gJ2kxOG5leHQnO1xuaW1wb3J0IF8gZnJvbSBcImxvZGFzaFwiO1xuaW1wb3J0IHsgc3lzdGVtUmVzb3VyY2UgfSBmcm9tICcuLi9jb21tb25Db250cm9scy9MYW5ndWFnZVN0cmluZ3MnO1xuaW1wb3J0IHsgQ29udHJvbCB9IGZyb20gJy4uL2NvbnRyb2xzL0NvbnRyb2wnO1xuaW1wb3J0IHsgaW1wbGVtZW50c0ludGVyYWN0aW9uTW9kZWxDb250cmlidXRvciB9IGZyb20gJy4uL2NvbnRyb2xzL21peGlucy9JbnRlcmFjdGlvbk1vZGVsQ29udHJpYnV0b3InO1xuaW1wb3J0IHsgQ29udHJvbEludGVyYWN0aW9uTW9kZWxHZW5lcmF0b3IsIGdlbmVyYXRlTW9kZWxEYXRhIH0gZnJvbSAnLi4vaW50ZXJhY3Rpb25Nb2RlbEdlbmVyYXRpb24vQ29udHJvbEludGVyYWN0aW9uTW9kZWxHZW5lcmF0b3InO1xuaW1wb3J0IHsgTW9kZWxEYXRhIH0gZnJvbSAnLi4vaW50ZXJhY3Rpb25Nb2RlbEdlbmVyYXRpb24vTW9kZWxUeXBlcyc7XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tICcuLi9sb2dnaW5nL0xvZ2dlcic7XG5pbXBvcnQgeyBDb250cm9sUmVzcG9uc2VCdWlsZGVyIH0gZnJvbSAnLi4vcmVzcG9uc2VHZW5lcmF0aW9uL0NvbnRyb2xSZXNwb25zZUJ1aWxkZXInO1xuaW1wb3J0IHsgU3lzdGVtQWN0IH0gZnJvbSAnLi4vc3lzdGVtQWN0cy9TeXN0ZW1BY3QnO1xuaW1wb3J0IHsgQ29udHJvbElucHV0IH0gZnJvbSAnLi9Db250cm9sSW5wdXQnO1xuaW1wb3J0IHsgQ29udHJvbFJlc3VsdCB9IGZyb20gJy4vQ29udHJvbFJlc3VsdCc7XG5pbXBvcnQgeyBpc0NvbnRhaW5lckNvbnRyb2wgfSBmcm9tICcuL2ludGVyZmFjZXMvSUNvbnRhaW5lckNvbnRyb2wnO1xuaW1wb3J0IHsgSUNvbnRyb2wgfSBmcm9tICcuL2ludGVyZmFjZXMvSUNvbnRyb2wnO1xuaW1wb3J0IHsgSUNvbnRyb2xNYW5hZ2VyIH0gZnJvbSAnLi9pbnRlcmZhY2VzL0lDb250cm9sTWFuYWdlcic7XG5cbmNvbnN0IGxvZyA9IG5ldyBMb2dnZXIoJ0Fza1Nka0NvbnRyb2xzOkNvbnRyb2xNYW5hZ2VyJyk7XG5cbi8qKlxuICogUHJvcGVydGllcyBmb3IgY3JlYXRpbmcgYSBDb250cm9sTWFuYWdlciBpbnN0YW5jZS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDb250cm9sTWFuYWdlclByb3BzIHtcbiAgICBsb2NhbGU/OiBzdHJpbmcsXG4gICAgaTE4blJlc291cmNlcz86IFJlc291cmNlXG59XG5cbi8qKlxuICogRGVmaW5lcyB0aGUgaGlnaC1sZXZlbCBmdW5jdGlvbmFsaXR5IGZvciBhIHNraWxsIGJ1aWx0IHdpdGggQ29udHJvbHMuXG4gKlxuICogRWFjaCBza2lsbCB0aGF0IHVzZXMgY29udHJvbHMgc2hvdWxkIGRlZmluZSBhIGNvbmNyZXRlIHN1Yi1jbGFzcyB0aGF0XG4gKiBpbXBsZW1lbnRzIGBjcmVhdGVDb250cm9sVHJlZWAgYW5kIG9wdGlvbmFsbHkgb3ZlcnJpZGVzIG90aGVyIG1ldGhvZHMuXG4gKlxuICogU3VtbWFyeTpcbiAqICAqIGNyZWF0ZUNvbnRyb2xUcmVlKCkgY3JlYXRlcyBhIGhpZXJhcmNoeSBvZiBjb250cm9scyB0aGF0IGNvb3BlcmF0aXZlbHlcbiAqICAgIG1hbmFnZSB0aGUgc2tpbGwgYmVoYXZpb3IuXG4gKiAgICogVGhlIG1ldGhvZHMgb24gdGhlIHJvb3QgY29udHJvbCB3aWxsIGJlIGNhbGxlZCB0byBwcm9jZXNzIHRoZSB1c2VyJ3NcbiAqICAgICBpbnB1dCBhbmQgdG8gZ2VuZXJhdGUgc3lzdGVtIGluaXRpYXRpdmUuXG4gKlxuICogICogcmVuZGVyKCkgaXMgdGhlIGVudHJ5LXBvaW50IGZvciB0aGUgcmVuZGVyLXBoYXNlLlxuICogICAqIEhpZ2gtbGV2ZWwgb3ZlcnJpZGVzIGFuZCBtdWx0aS1hY3QgcmVuZGVyaW5nIHNob3VsZCBiZSBwZXJmb3JtZWQgYnlcbiAqICAgICBgY29udHJvbE1hbmFnZXIucmVuZGVyKClgLiBUaGUgZGVmYXVsdCBpcyB0byByZW5kZXIgZWFjaCBhY3Qgb25lLWJ5LW9uZVxuICogICAgIGJ5IGNhbGxpbmcgYGNvbnRyb2wucmVuZGVyQWN0KGFjdClgLiAgVGhpcyBidWlsZHMgdXAgYSByZXN1bHQgYnlcbiAqICAgICBjb25jYXRlbmF0aW9uIG9mIHJlc3BvbnNlIGZyYWdtZW50cyB3aGljaCBpcyBzdWZmaWNpZW50IGluIG1hbnkgY2FzZXMuXG4gKlxuICogICogVGhlIGBDb250cm9sUmVzdWx0YCBjb250YWlucyBhIGxpc3Qgb2YgU3lzdGVtQWN0cyB0aGF0IGRlc2NyaWJlICp3aGF0KlxuICogICAgc2hvdWxkIGJlIGNvbW11bmljYXRlZCB0byB0aGUgdXNlciBidXQgZ2VuZXJhbGx5IHNob3VsZCBub3QgZGVzY3JpYmUgKmhvdypcbiAqICAgIHRvIHByZXNlbnQgaXQuXG4gKlxuICogICogYGhhbmRsZUludGVybmFsRXJyb3JgIHByb3ZpZGVzIGFuIGVudHJ5LXBvaW50IGZvciBjdXN0b20gaGFuZGxpbmcgb2ZcbiAqICAgIGludGVybmFsIGVycm9ycy5cbiAqXG4gKiAgKiBgYnVpbGRJbnRlcmFjdGlvbk1vZGVsYCBwcm92aWRlcyBhbiBlbnRyeS1wb2ludCBmb3IgYnVpbGRpbmcgdGhlXG4gKiAgICBDb250cm9sLXNwZWNpZmljIGFzcGVjdHMgb2Ygc2tpbGwncyBJbnRlcmFjdGlvbiBNb2RlbC5cbiAqXG4gKiBJbnRlcm5hdGlvbmFsaXphdGlvbiBhbmQgTG9jYWxpemF0aW9uXG4gKiAgKiBDb250cm9scyB0aGVtc2VsdmVzIGFyZSBsb2NhdGlvbi1hZ25vc3RpYy4gIFRoZXkgY29uc3VtZSBhYnN0cmFjdCBpbnB1dHNcbiAqICAgIChJbnRlbnRzLCBldGMpIGFuZCBwcm9kdWNlIGFic3RyYWN0IG91dHB1dHMgKFN5c3RlbUFjdHMpXG4gKlxuICogICogTWFwcGluZyBsb2NhbGl6ZWQgaW5wdXQgdG8gYWJzdHJhY3QgaW5wdXRzIGlzIHRoZSByb2xlIG9mIE5MVSBhbmQgdGhlXG4gKiAgICBuZWNlc3NhcnkgaW5mb3JtYXRpb24gaXMgc3RvcmVkIGluIHRoZSBJbnRlcmFjdGlvbiBNb2RlbC5cbiAqICAgKiBUaGUgQ29udHJvbE1hbmFnZXIgcHJvcHMgaW5jbHVkZXMgYSBiYWcgb2YgbG9jYWxpemF0aW9uIGRhdGEgdGhhdCBpcyB1c2VkXG4gKiAgICAgZHVyaW5nIGludGVyYWN0aW9uLW1vZGVsIGJ1aWxkaW5nIGZvciBhIGdpdmVuIGxvY2FsZS5cbiAqICAgKiBUaGUgZnJhbWV3b3JrIHNoaXBzIHdpdGggYSBkZWZhdWx0IHNldCBvZiBpbnRlcmFjdGlvbiBtb2RlbCBkYXRhIGZvclxuICogICAgIGVuLVVTLlxuICpcbiAqICAqIE1hcHBpbmcgYWJzdHJhY3Qgb3V0cHV0IHRvIHBoeXNpY2FsIG91dHB1dCAocHJvbXB0cywgQVBMIHN0cmluZ3MpIGV0YyBpc1xuICogICAgdGhlIHJvbGUgb2YgdGhlIHJlbmRlcmluZyBwaGFzZS4gIFRoaXMgaW5mb3JtYXRpb24gaXMgcGFydCBvZiB0aGUgc2tpbGxcbiAqICAgIGRlZmluaXRpb24gYnV0IGNhbiBiZSBsb2NhdGVkIGluIHZhcmlvdXMgcGxhY2VzOiBlaXRoZXIgaW4gYSBtb25vbGl0aGljXG4gKiAgICByZW5kZXIoKSBmdW5jdGlvbiwgb3Igc2NhdHRlcmVkIGFyb3VuZCB0aGUgdmFyaW91cyBDb250cm9scyBhbmQgQWN0cy5cbiAqL1xuZXhwb3J0IGFic3RyYWN0IGNsYXNzIENvbnRyb2xNYW5hZ2VyIGltcGxlbWVudHMgSUNvbnRyb2xNYW5hZ2VyIHtcblxuICAgIHByb3BzOiBSZXF1aXJlZDxDb250cm9sTWFuYWdlclByb3BzPjtcblxuICAgIHN0YXRpYyBtZXJnZVdpdGhEZWZhdWx0UHJvcHMocHJvcHM6IENvbnRyb2xNYW5hZ2VyUHJvcHMgfCB1bmRlZmluZWQpOiBSZXF1aXJlZDxDb250cm9sTWFuYWdlclByb3BzPiB7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRzOiBSZXF1aXJlZDxDb250cm9sTWFuYWdlclByb3BzPiA9IHtcbiAgICAgICAgICAgIGxvY2FsZTogJ2VuLVVTJyxcbiAgICAgICAgICAgIGkxOG5SZXNvdXJjZXM6IHt9XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIF8ubWVyZ2VXaXRoKGRlZmF1bHRzLCBwcm9wcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBhIENvbnRyb2wgTWFuYWdlci5cbiAgICAgKiBAcGFyYW0gcHJvcHMgLSBwcm9wc1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHByb3BzPzogQ29udHJvbE1hbmFnZXJQcm9wcykge1xuICAgICAgICB0aGlzLnByb3BzID0gQ29udHJvbE1hbmFnZXIubWVyZ2VXaXRoRGVmYXVsdFByb3BzKHByb3BzKTtcbiAgICAgICAgY29uc3QgcmVzb3VyY2U6IFJlc291cmNlID0gXy5tZXJnZShzeXN0ZW1SZXNvdXJjZSwgdGhpcy5wcm9wcy5pMThuUmVzb3VyY2VzKTtcbiAgICAgICAgaTE4bkluaXQodGhpcy5wcm9wcy5sb2NhbGUsIHJlc291cmNlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHRyZWUgb2YgY29udHJvbHMgdG8gaGFuZGxlIHN0YXRlIG1hbmFnZW1lbnQgYW5kIGRpYWxvZ1xuICAgICAqIGRlY2lzaW9ucyBmb3IgdGhlIHNraWxsLlxuICAgICAqXG4gICAgICogVXNhZ2U6XG4gICAgICogLSBFYWNoIGNvbnRyb2wgaW4gdGhlIHRyZWUgY2FuIGFuZCBzaG91bGQgYmUgY3JlYXRlZCB3aXRoIGVtcHR5IHN0YXRlLlxuICAgICAqICAgVGhlIENvbnRyb2xIYW5kbGVyIHdpbGwgZGlzdHJpYnV0ZSB0aGUgc2F2ZWQgc3RhdGVzIHRvIHRoZSBjb250cm9sc1xuICAgICAqICAgYXV0b21hdGljYWxseS5cbiAgICAgKlxuICAgICAqIC0gQSBzaW5nbGUgY29udHJvbCBpcyBsZWdhbCBhbmQgd2lsbCBzdWZmaWNlIGZvciBzbWFsbCBza2lsbHMuIEZvciBsYXJnZXJcbiAgICAgKiAgIHNraWxscyBhIHRyZWUgb2YgY29udHJvbHMgc3RydWN0dXJlZCB1c2luZyBAc2VlIENvbnRhaW5lckNvbnRyb2wgd2lsbFxuICAgICAqICAgaGVscCBtYW5hZ2Ugc2tpbGwgY29tcGxleGl0eS5cbiAgICAgKlxuICAgICAqIC0gSW4gYWR2YW5jZWQgc2NlbmFyaW9zIHRoZSB0cmVlIHNoYXBlIG1heSBjaGFuZ2UgYXMgdGhlIHNraWxsIHNlc3Npb25cbiAgICAgKiAgIHByb2dyZXNzZXMuIFRoZSBzZXJpYWxpemFibGUgc3RhdGUgY2FuIGJlIGRpcmVjdGx5IGludGVycm9nYXRlZCB0b1xuICAgICAqICAgZGV0ZXJtaW5lIHdoYXQgdHJlZSB0byBidWlsZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzZXJpYWxpemFibGVTdGF0ZSAtIE1hcCBvZiBjb250cm9sIHN0YXRlIG9iamVjdHMga2V5ZWQgYnlcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgYGNvbnRyb2xJZGAuIFRoaXMgaXMgaW50ZW5kZWQgdG8gYmUgcmVhZC1vbmx5IG9uXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgIGFuZCBvbmx5IHVzZWQgaW4gYWR2YW5jZWQgY2FzZXMgaW4gd2hpY2ggdGhlXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgIHRyZWUgaGFzIGEgZHluYW1pYyBzaGFwZS5cbiAgICAgKiBAcmV0dXJucyBBIGBDb250cm9sYCBvciBgQ29udGFpbmVyQ29udHJvbGAgdGhhdCBpcyB0aGUgcm9vdCBvZiBhIHRyZWUuXG4gICAgICovXG4gICAgYWJzdHJhY3QgY3JlYXRlQ29udHJvbFRyZWUoc2VyaWFsaXphYmxlU3RhdGU6IHsgW2tleTogc3RyaW5nXTogYW55IH0pOiBDb250cm9sO1xuXG4gICAgLyoqXG4gICAgICogVHJhbnNmb3JtcyB0aGUgaW5mb3JtYXRpb24gaW4gQ29udHJvbFJlc3VsdCBpbnRvIHVzZXItZmFjaW5nIGNvbnRlbnRcbiAgICAgKiAocHJvbXB0cyBhbmQgQVBMKS5cbiAgICAgKlxuICAgICAqIERlZmF1bHQ6IFRoZSBkZWZhdWx0IHJlbmRlcmluZyBzdHJhdGVneSByZW5kZXJzIGVhY2ggYFN5c3RlbUFjdGAgaW4gdHVyblxuICAgICAqICAgICAgICAgIGJ5IGNhbGxpbmcgYGFjdC5jb250cm9sLnJlbmRlcihhY3QpYC4gVGhpcyBzdHJhdGVneSBsZWFkcyB0b1xuICAgICAqICAgICAgICAgIHByb21wdHMgdGhhdCBhcmUgYSBjb25jYXRlbmF0aW9uIG9mIHRoZSBwcm9tcHQtZnJhZ21lbnQgZm9yIGVhY2hcbiAgICAgKiAgICAgICAgICBgU3lzdGVtQWN0YC5cbiAgICAgKlxuICAgICAqIFVzYWdlOlxuICAgICAqICAqIEluIG1hbnkgc2l0dWF0aW9ucyByZW5kZXJpbmcgdGhlIGFjdHMgb25lLWJ5LW9uZSBpcyBzdWZmaWNpZW50IGFzIHRoZVxuICAgICAqICAgIGNvbmNhdGVuYXRpb24gb2YgcHJvbXB0IGZyYWdtZW50cyBsZWFkcyB0byB1c2FibGUgcHJvbXB0cy4gIEZvclxuICAgICAqICAgIGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGBgYGpzXG4gICAgICogICAgW1ZhbHVlU2V0QWN0KGFnZUN0cmwsIDUpLCBSZXF1ZXN0VmFsdWVBY3QobmFtZUN0cmwpXVxuICAgICAqIGBgYFxuICAgICAqICAgIG1heSBiZSByZW5kZXJlZCBzZXF1ZW50aWFsbHkgdG8gcHJvZHVjZTpcbiAgICAgKlxuICAgICAqIGBgYGpzXG4gICAgICogICAgLT4gJ09LLCA1LiBXaGF0IGlzIHlvdXIgbmFtZT9cIlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogICAgKiBGb3IgbW9yZSBjb21wbGV4IHNpdHVhdGlvbnMsIG92ZXJyaWRlIHRoaXMgbWV0aG9kIGFuZCBpbXBsZW1lbnQgYVxuICAgICAqICAgICAgY3VzdG9tIHJlbmRlcmluZyBzdHJhdGVneS4gIE9mdGVuIHRoZSBzb2x1dGlvbiB3aWxsIGJlIHRvIGltcGxlbWVudFxuICAgICAqICAgICAgc29tZSBzcGVjaWFsIGNhc2VzIGFuZCBvdGhlcndpc2UgZmFsbGJhY2sgdG8gdGhlIGRlZmF1bHQgYnkgY2FsbGluZ1xuICAgICAqICAgICAgc3VwZXIucmVuZGVyKCkgb3IgYnkgZGlyZWN0bHkgY2FsbGluZ1xuICAgICAqICAgICAgYENvbnRyb2xNYW5hZ2VyLnJlbmRlckFjdHNPbmVCeU9uZSgpYC5cbiAgICAgKlxuICAgICAqL1xuICAgIHJlbmRlcihyZXN1bHQ6IENvbnRyb2xSZXN1bHQsIGlucHV0OiBDb250cm9sSW5wdXQsIGNvbnRyb2xSZXNwb25zZUJ1aWxkZXI6IENvbnRyb2xSZXNwb25zZUJ1aWxkZXIpOiB2b2lkIHwgUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIHJlbmRlckFjdHNJblNlcXVlbmNlKHJlc3VsdC5hY3RzLCBpbnB1dCwgY29udHJvbFJlc3BvbnNlQnVpbGRlcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlcyBhbiBpbnRlcm5hbCBlcnJvci5cbiAgICAgKlxuICAgICAqIFRoaXMgaXMgaW50ZW5kZWQgZm9yIGxvZ2dpbmcsIHJlcG9ydGluZyBhbmQgcGVyaGFwcyBtZW50aW9uaW5nIHRoZVxuICAgICAqIHNpdHVhdGlvbiB0byB0aGUgdXNlci4gVGhlIHVzZXIgc2Vzc2lvbiB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgY2xvc2VkLlxuICAgICAqXG4gICAgICogRGVmYXVsdDogVGhlIGVycm9yIG9iamVjdCBpcyBjb252ZXJ0ZWQgaW50byBhbiBvYmplY3Qgd2l0aCBlbnVtZXJhYmxlXG4gICAgICogcHJvcGVydGllcyBhbmQgbG9nZ2VkIGF0IGxvZ0xldmVsPWVycm9yXG4gICAgICogQHBhcmFtIGlucHV0IC0gSW5wdXRcbiAgICAgKiBAcGFyYW0gZXJyb3IgLSBFcnJvclxuICAgICAqIEBwYXJhbSByZXNwb25zZUJ1aWxkZXIgLSBSZXNwb25zZSBidWlsZGVyXG4gICAgICovXG4gICAgaGFuZGxlSW50ZXJuYWxFcnJvcihpbnB1dDogQ29udHJvbElucHV0LCBlcnJvcjogYW55LCByZXNwb25zZUJ1aWxkZXI6IFJlc3BvbnNlQnVpbGRlcik6IHZvaWQge1xuICAgICAgICBjb25zdCBlcnIgPSBlcnJvci5zdGFjayAhPT0gdW5kZWZpbmVkID8geyBuYW1lOiBlcnJvci5uYW1lLCBtc2c6IGVycm9yLm1lc3NhZ2UsIHN0YWNrOiBlcnJvci5zdGFjayB9IDogZXJyb3I7IC8vIEVycm9yIGRvZXNuJ3QgaGF2ZSBlbnVtZXJhYmxlIHByb3BlcnRpZXMsIHNvIHdlIGNvbnZlcnQgaXQuXG4gICAgICAgIGxvZy5lcnJvcihgRXJyb3IgaGFuZGxlZDogJHtKU09OLnN0cmluZ2lmeShlcnIpfWApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEJ1aWxkcyBpbnRlcmFjdGlvbiBtb2RlbCBjb250ZW50IHJlcXVpcmVkIGJ5IHRoZSBDb250cm9sIHRyZWUuXG4gICAgICpcbiAgICAgKiBVc2FnZTpcbiAgICAgKiAtIFRoZSBpbURhdGFNYXAgaGFzICdlbi1VUycgbW9kZWxEYXRhIHJlZ2lzdGVyZWQgYnkgZGVmYXVsdFxuICAgICAqIC0gVGhlIGRldmVsb3BlciBtYXkgY29uZmlndXJlIGFuZCByZWdpc3RlciBhZGRpdGlvbmFsIGBpbURhdGFNYXBgXG4gICAgICogICBpbnN0YW5jZXMgdG8gc3VwcG9ydCBhZGRpdGlvbmFsIGxvY2FsZXNcbiAgICAgKlxuICAgICAqICogSWYgaW1EYXRhTWFwIGRvZXNuJ3QgaGF2ZSBkYXRhIGZvciB0aGUgcmVxdWVzdGVkIGxvY2FsZSBhXG4gICAgICogICBgTG9jYWxlTm90U3VwcG9ydGVkRXJyb3JgIHdpbGwgYmUgdGhyb3duXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZ2VuZXJhdG9yIC0gSW50ZXJhY3Rpb24gTW9kZWwgR2VuZXJhdG9yXG4gICAgICovXG4gICAgYnVpbGRJbnRlcmFjdGlvbk1vZGVsKGdlbmVyYXRvcjogQ29udHJvbEludGVyYWN0aW9uTW9kZWxHZW5lcmF0b3IpOiB2b2lkIHtcbiAgICAgICAgY29uc3Qgcm9vdENvbnRyb2wgPSB0aGlzLmNyZWF0ZUNvbnRyb2xUcmVlKHt9KTtcbiAgICAgICAgY29uc3QgaW1EYXRhOiBNb2RlbERhdGEgPSBnZW5lcmF0ZU1vZGVsRGF0YSgpO1xuICAgICAgICB1cGRhdGVJTUZvckNvbnRyb2xUcmVlKGdlbmVyYXRvciwgcm9vdENvbnRyb2wsIGltRGF0YSk7XG4gICAgfVxufVxuXG4vKipcbiAqIFJlbmRlciBlYWNoIG9mIHRoZSBhY3RzLCBvbmUtYnktb25lLlxuICpcbiAqXG4gKiBAcGFyYW0gc3lzdGVtQWN0cyAtIFRoZSBzeXN0ZW0gYWN0cyB0byByZW5kZXJcbiAqIEBwYXJhbSBpbnB1dCAtIElucHV0XG4gKiBAcGFyYW0gcmVzcG9uc2VCdWlsZGVyIC0gUmVzcG9uc2UgYnVpbGRlci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbmRlckFjdHNJblNlcXVlbmNlKHN5c3RlbUFjdHM6IFN5c3RlbUFjdFtdLCBpbnB1dDogQ29udHJvbElucHV0LCBjb250cm9sUmVzcG9uc2VCdWlsZGVyOiBDb250cm9sUmVzcG9uc2VCdWlsZGVyKTogdm9pZCB7XG4gICAgZm9yIChjb25zdCBhY3Qgb2Ygc3lzdGVtQWN0cykge1xuICAgICAgICBhY3QuY29udHJvbC5yZW5kZXJBY3QoYWN0LCBpbnB1dCwgY29udHJvbFJlc3BvbnNlQnVpbGRlcik7XG4gICAgfVxufVxuXG4vKipcbiAqIFZpc2l0cyBldmVyeSBjb250cm9sIGluIHRoZSB0cmVlIGFuZCB1cGRhdGVzIHRoZSBpbnRlcmFjdGlvbiBtb2RlbCBmb3IgZWFjaFxuICogY29udHJvbC4gR28gdGhyb3VnaCB0aGUgZW50aXJlIGNvbnRyb2wgdHJlZSBhbmQgdXBkYXRlIElNXG4gKiBAcGFyYW0gZ2VuZXJhdG9yIC0gSW50ZXJhY3Rpb24gbW9kZWwgZ2VuZXJhdG9yXG4gKiBAcGFyYW0gY29udHJvbCAtIFJvb3QgY29udHJvbFxuICogQHBhcmFtIGltRGF0YSAtIExvY2FsaXplZCBkYXRhIGZvciB1c2UgaW4gaW50ZXJhY3Rpb24gbW9kZWxcbiAqL1xuLy8gVE9ETzogcGFyYW0tb3JkZXJpbmdcbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVJTUZvckNvbnRyb2xUcmVlKGdlbmVyYXRvcjogQ29udHJvbEludGVyYWN0aW9uTW9kZWxHZW5lcmF0b3IsIGNvbnRyb2w6IElDb250cm9sLCBpbURhdGE6IE1vZGVsRGF0YSk6IHZvaWQge1xuICAgIGlmIChjb250cm9sIGluc3RhbmNlb2YgQ29udHJvbCAmJiBpbXBsZW1lbnRzSW50ZXJhY3Rpb25Nb2RlbENvbnRyaWJ1dG9yKGNvbnRyb2wpKSB7XG4gICAgICAgIGNvbnRyb2wudXBkYXRlSW50ZXJhY3Rpb25Nb2RlbChnZW5lcmF0b3IsIGltRGF0YSk7XG4gICAgICAgIGNvbnN0IHRhcmdldElkczogc3RyaW5nW10gfCB1bmRlZmluZWQgPSBjb250cm9sLmdldFRhcmdldElkcygpO1xuICAgICAgICBpZiAodGFyZ2V0SWRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRhcmdldElkcy5mb3JFYWNoKCh0YXJnZXRJZCkgPT4ge1xuICAgICAgICAgICAgICAgIGdlbmVyYXRvci50YXJnZXRTbG90SWRzID0gZ2VuZXJhdG9yLnRhcmdldFNsb3RJZHMuYWRkKHRhcmdldElkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgY29udGFpbmVyIGNvbnRyb2wsIGRvIHNhbWUgdGhpbmcgcmVjdXJzaXZlbHlcbiAgICBpZiAoaXNDb250YWluZXJDb250cm9sKGNvbnRyb2wpKSB7XG4gICAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgY29udHJvbC5jaGlsZHJlbikge1xuICAgICAgICAgICAgdXBkYXRlSU1Gb3JDb250cm9sVHJlZShnZW5lcmF0b3IsIGNoaWxkLCBpbURhdGEpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIEluaXRpYWxpemVzIHRoZSBpbnRlcm5hdGlvbmFsaXphdGlvbiBzeXN0ZW0gKGkxOG5leHQpLlxuICpcbiAqIFRoaXMgbG9hZHMgZGF0YSBmb3IgdGhlIHNwZWNpZmllZCBsb2NhbCBmcm9tIHRoZSByZXNvdXJjZXMuXG4gKlxuICogQHBhcmFtIGxvY2FsZSAtIFRoZSBsb2NhbGUgdG8gc3BlY2lhbGl6ZSB0by5cbiAqIEBwYXJhbSByZXNvdXJjZXMgLSBSZXNvdXJjZXMgZm9yIGFsbCBzdXBwb3J0ZWQgbG9jYWxlcy5cbiAqL1xuZnVuY3Rpb24gaTE4bkluaXQobG9jYWxlOiBzdHJpbmcsIHJlc291cmNlczogUmVzb3VyY2UpOiB2b2lkIHtcbiAgICBpZiAoIWxvY2FsZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BsZWFzZSBzcGVjaWZ5IHRoZSBsYW5ndWFnZS4nKTtcbiAgICB9XG4gICAgdm9pZCBpMThuZXh0LmluaXQoe1xuICAgICAgICBsbmc6IGxvY2FsZSxcbiAgICAgICAgcmVzb3VyY2VzLFxuICAgICAgICBmYWxsYmFja0xuZzogJ2VuJyxcbiAgICB9KTtcbn1cbiJdfQ==