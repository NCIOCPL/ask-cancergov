"use strict";
/*
 * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const chai_1 = require("chai");
const mocha_1 = require("mocha");
const src_1 = require("../src");
const ControlManager_1 = require("../src/controls/ControlManager");
const GeneralControlIntent_1 = require("../src/intents/GeneralControlIntent");
const ControlHandler_1 = require("../src/runtime/ControlHandler");
const SkillInvoker_1 = require("../src/utils/testSupport/SkillInvoker");
src_1.waitForDebugger();
/*
 * Tests a control that has state (Set<string>) that doesn't automatically serialize with JSON.stringify.
 *
 * The test shows the control changing state and being serialized and deserialized.
 * To accomplish this, the state object implements toJSON() and assign()
 *   - the name and signature for toJSON() is defined by JSON.stringify and called automatically by JSON.stringify
 *   - the name and signature for fromJSON() is defined by the Control framework and used as an alternative to Object.assign() when present.

 */
mocha_1.suite("== Custom Serde ==", () => {
    mocha_1.test('explicit confirmation and disaffirm', async () => {
        // Note: this test demonstrates using testTurn to run a multi-turn scenario with assertions between turns.
        const requestHandler = new ControlHandler_1.ControlHandler(new CustomSerdeControlManager());
        const invoker = new SkillInvoker_1.SkillInvoker(requestHandler);
        await src_1.testTurn(invoker, 'U: ', src_1.TestInput.of(GeneralControlIntent_1.GeneralControlIntent.of({})), 'A:');
        chai_1.expect(requestHandler.getSerializableControlStates().customControl[0]).exist.and.equals('x');
        await src_1.testTurn(invoker, 'U: ', src_1.TestInput.of(GeneralControlIntent_1.GeneralControlIntent.of({})), 'A:');
        chai_1.expect(requestHandler.getSerializableControlStates().customControl[0]).exist.and.equals('y');
    });
});
class CustomSerdeControlManager extends ControlManager_1.ControlManager {
    createControlTree(state) {
        return new CustomSerdeControl({
            id: 'customControl'
        });
    }
}
class CustomSerdeControlState {
    constructor(value) {
        this.value = value;
    }
}
class CustomSerdeControl extends src_1.Control {
    constructor(props, state) {
        super(props.id);
        this.state = state !== null && state !== void 0 ? state : new CustomSerdeControlState(new Set());
    }
    canHandle(input) {
        return true;
    }
    async handle(input, resultBuilder) {
        if (this.state.value.size === 0) {
            this.state.value.add('x');
        }
        else if (this.state.value.size === 1 && this.state.value.has('x')) {
            this.state.value.delete('x');
            this.state.value.add('y');
        }
        return;
    }
    canTakeInitiative(input) {
        return false;
    }
    async takeInitiative(input, resultBuilder) {
        throw new Error("Method not implemented.");
    }
    getSerializableState() {
        // render the set as a simple list.
        return [...this.state.value.keys()];
    }
    setSerializableState(obj) {
        if (obj !== undefined) {
            // refreshes the set from the serialized array
            this.state.value = new Set();
            for (const x of obj) {
                this.state.value.add(x);
            }
        }
    }
    renderAct(act, input, builder) {
        throw new Error("Method not implemented.");
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ3VzdG9tU2VyZGVUZXN0cy5zcGVjLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vdGVzdC9DdXN0b21TZXJkZVRlc3RzLnNwZWMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBOzs7Ozs7Ozs7OztHQVdHOztBQUVILCtCQUE4QjtBQUM5QixpQ0FBb0M7QUFDcEMsZ0NBQWtGO0FBR2xGLG1FQUFnRTtBQUVoRSw4RUFBMkU7QUFFM0Usa0VBQStEO0FBQy9ELHdFQUFxRTtBQUVyRSxxQkFBZSxFQUFFLENBQUM7QUFHbEI7Ozs7Ozs7O0dBUUc7QUFDSCxhQUFLLENBQUMsb0JBQW9CLEVBQUUsR0FBRyxFQUFFO0lBRTdCLFlBQUksQ0FBQyxxQ0FBcUMsRUFBRSxLQUFLLElBQUksRUFBRTtRQUNuRCwwR0FBMEc7UUFDMUcsTUFBTSxjQUFjLEdBQUcsSUFBSSwrQkFBYyxDQUFDLElBQUkseUJBQXlCLEVBQUUsQ0FBQyxDQUFDO1FBQzNFLE1BQU0sT0FBTyxHQUFHLElBQUksMkJBQVksQ0FBQyxjQUFjLENBQUMsQ0FBQztRQUNqRCxNQUFNLGNBQVEsQ0FDVixPQUFPLEVBQ1AsS0FBSyxFQUFFLGVBQVMsQ0FBQyxFQUFFLENBQUMsMkNBQW9CLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQ2hELElBQUksQ0FBQyxDQUFDO1FBR1YsYUFBTSxDQUFFLGNBQWMsQ0FBQyw0QkFBNEIsRUFBRSxDQUFDLGFBQTBCLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUUzRyxNQUFNLGNBQVEsQ0FDVixPQUFPLEVBQ1AsS0FBSyxFQUFFLGVBQVMsQ0FBQyxFQUFFLENBQUMsMkNBQW9CLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQ2hELElBQUksQ0FBQyxDQUFDO1FBRVYsYUFBTSxDQUFFLGNBQWMsQ0FBQyw0QkFBNEIsRUFBRSxDQUFDLGFBQTBCLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUMvRyxDQUFDLENBQUMsQ0FBQztBQUNQLENBQUMsQ0FBQyxDQUFDO0FBRUgsTUFBTSx5QkFBMEIsU0FBUSwrQkFBYztJQUVsRCxpQkFBaUIsQ0FBQyxLQUFVO1FBQ3hCLE9BQU8sSUFBSSxrQkFBa0IsQ0FDekI7WUFDSSxFQUFFLEVBQUUsZUFBZTtTQUN0QixDQUNKLENBQUM7SUFDTixDQUFDO0NBQ0o7QUFFRCxNQUFNLHVCQUF1QjtJQUd6QixZQUFZLEtBQWtCO1FBQzFCLElBQUksQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDO0lBQ3ZCLENBQUM7Q0FDSjtBQUVELE1BQU0sa0JBQW1CLFNBQVEsYUFBTztJQUlwQyxZQUFZLEtBQW1CLEVBQUUsS0FBK0I7UUFDNUQsS0FBSyxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsQ0FBQztRQUNoQixJQUFJLENBQUMsS0FBSyxHQUFHLEtBQUssYUFBTCxLQUFLLGNBQUwsS0FBSyxHQUFJLElBQUksdUJBQXVCLENBQUMsSUFBSSxHQUFHLEVBQVUsQ0FBQyxDQUFDO0lBQ3pFLENBQUM7SUFHRCxTQUFTLENBQUMsS0FBbUI7UUFDekIsT0FBTyxJQUFJLENBQUM7SUFDaEIsQ0FBQztJQUVELEtBQUssQ0FBQyxNQUFNLENBQUMsS0FBbUIsRUFBRSxhQUFtQztRQUNqRSxJQUFJLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLElBQUksS0FBSyxDQUFDLEVBQUU7WUFDN0IsSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1NBQzdCO2FBQ0ksSUFBSSxJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxJQUFJLEtBQUssQ0FBQyxJQUFJLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsRUFBRTtZQUMvRCxJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7WUFDN0IsSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1NBQzdCO1FBRUQsT0FBTztJQUNYLENBQUM7SUFFRCxpQkFBaUIsQ0FBQyxLQUFtQjtRQUNqQyxPQUFPLEtBQUssQ0FBQztJQUNqQixDQUFDO0lBQ0QsS0FBSyxDQUFDLGNBQWMsQ0FBQyxLQUFtQixFQUFFLGFBQW1DO1FBQ3pFLE1BQU0sSUFBSSxLQUFLLENBQUMseUJBQXlCLENBQUMsQ0FBQztJQUMvQyxDQUFDO0lBRUQsb0JBQW9CO1FBQ2hCLG1DQUFtQztRQUNuQyxPQUFPLENBQUMsR0FBSSxJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDO0lBQ3pDLENBQUM7SUFFRCxvQkFBb0IsQ0FBQyxHQUFhO1FBQzlCLElBQUksR0FBRyxLQUFLLFNBQVMsRUFBRTtZQUNuQiw4Q0FBOEM7WUFDOUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLEdBQUcsSUFBSSxHQUFHLEVBQUUsQ0FBQztZQUM3QixLQUFLLE1BQU0sQ0FBQyxJQUFJLEdBQUcsRUFBRTtnQkFDakIsSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO2FBQzNCO1NBQ0o7SUFDTCxDQUFDO0lBRUQsU0FBUyxDQUFDLEdBQWMsRUFBRSxLQUFtQixFQUFFLE9BQStCO1FBQzFFLE1BQU0sSUFBSSxLQUFLLENBQUMseUJBQXlCLENBQUMsQ0FBQztJQUMvQyxDQUFDO0NBQ0oiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogQ29weXJpZ2h0IDIwMjAgQW1hem9uLmNvbSwgSW5jLiBvciBpdHMgYWZmaWxpYXRlcy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIikuXG4gKiBZb3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBBIGNvcHkgb2YgdGhlIExpY2Vuc2UgaXMgbG9jYXRlZCBhdFxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBvciBpbiB0aGUgXCJsaWNlbnNlXCIgZmlsZSBhY2NvbXBhbnlpbmcgdGhpcyBmaWxlLiBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWRcbiAqIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlclxuICogZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmdcbiAqIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBleHBlY3QgfSBmcm9tIFwiY2hhaVwiO1xuaW1wb3J0IHsgc3VpdGUsIHRlc3QgfSBmcm9tIFwibW9jaGFcIjtcbmltcG9ydCB7IENvbnRyb2wsIFN5c3RlbUFjdCwgVGVzdElucHV0LCB0ZXN0VHVybiwgd2FpdEZvckRlYnVnZ2VyIH0gZnJvbSAnLi4vc3JjJztcbmltcG9ydCB7IENvbnRyb2xQcm9wcywgQ29udHJvbFN0YXRlIH0gZnJvbSAnLi4vc3JjL2NvbnRyb2xzL0NvbnRyb2wnO1xuaW1wb3J0IHsgQ29udHJvbElucHV0IH0gZnJvbSAnLi4vc3JjL2NvbnRyb2xzL0NvbnRyb2xJbnB1dCc7XG5pbXBvcnQgeyBDb250cm9sTWFuYWdlciB9IGZyb20gJy4uL3NyYy9jb250cm9scy9Db250cm9sTWFuYWdlcic7XG5pbXBvcnQgeyBDb250cm9sUmVzdWx0QnVpbGRlciB9IGZyb20gJy4uL3NyYy9jb250cm9scy9Db250cm9sUmVzdWx0JztcbmltcG9ydCB7IEdlbmVyYWxDb250cm9sSW50ZW50IH0gZnJvbSAnLi4vc3JjL2ludGVudHMvR2VuZXJhbENvbnRyb2xJbnRlbnQnO1xuaW1wb3J0IHsgQ29udHJvbFJlc3BvbnNlQnVpbGRlciB9IGZyb20gJy4uL3NyYy9yZXNwb25zZUdlbmVyYXRpb24vQ29udHJvbFJlc3BvbnNlQnVpbGRlcic7XG5pbXBvcnQgeyBDb250cm9sSGFuZGxlciB9IGZyb20gJy4uL3NyYy9ydW50aW1lL0NvbnRyb2xIYW5kbGVyJztcbmltcG9ydCB7IFNraWxsSW52b2tlciB9IGZyb20gJy4uL3NyYy91dGlscy90ZXN0U3VwcG9ydC9Ta2lsbEludm9rZXInO1xuXG53YWl0Rm9yRGVidWdnZXIoKTtcblxuXG4vKlxuICogVGVzdHMgYSBjb250cm9sIHRoYXQgaGFzIHN0YXRlIChTZXQ8c3RyaW5nPikgdGhhdCBkb2Vzbid0IGF1dG9tYXRpY2FsbHkgc2VyaWFsaXplIHdpdGggSlNPTi5zdHJpbmdpZnkuXG4gKlxuICogVGhlIHRlc3Qgc2hvd3MgdGhlIGNvbnRyb2wgY2hhbmdpbmcgc3RhdGUgYW5kIGJlaW5nIHNlcmlhbGl6ZWQgYW5kIGRlc2VyaWFsaXplZC5cbiAqIFRvIGFjY29tcGxpc2ggdGhpcywgdGhlIHN0YXRlIG9iamVjdCBpbXBsZW1lbnRzIHRvSlNPTigpIGFuZCBhc3NpZ24oKVxuICogICAtIHRoZSBuYW1lIGFuZCBzaWduYXR1cmUgZm9yIHRvSlNPTigpIGlzIGRlZmluZWQgYnkgSlNPTi5zdHJpbmdpZnkgYW5kIGNhbGxlZCBhdXRvbWF0aWNhbGx5IGJ5IEpTT04uc3RyaW5naWZ5XG4gKiAgIC0gdGhlIG5hbWUgYW5kIHNpZ25hdHVyZSBmb3IgZnJvbUpTT04oKSBpcyBkZWZpbmVkIGJ5IHRoZSBDb250cm9sIGZyYW1ld29yayBhbmQgdXNlZCBhcyBhbiBhbHRlcm5hdGl2ZSB0byBPYmplY3QuYXNzaWduKCkgd2hlbiBwcmVzZW50LlxuXG4gKi9cbnN1aXRlKFwiPT0gQ3VzdG9tIFNlcmRlID09XCIsICgpID0+IHtcblxuICAgIHRlc3QoJ2V4cGxpY2l0IGNvbmZpcm1hdGlvbiBhbmQgZGlzYWZmaXJtJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAvLyBOb3RlOiB0aGlzIHRlc3QgZGVtb25zdHJhdGVzIHVzaW5nIHRlc3RUdXJuIHRvIHJ1biBhIG11bHRpLXR1cm4gc2NlbmFyaW8gd2l0aCBhc3NlcnRpb25zIGJldHdlZW4gdHVybnMuXG4gICAgICAgIGNvbnN0IHJlcXVlc3RIYW5kbGVyID0gbmV3IENvbnRyb2xIYW5kbGVyKG5ldyBDdXN0b21TZXJkZUNvbnRyb2xNYW5hZ2VyKCkpO1xuICAgICAgICBjb25zdCBpbnZva2VyID0gbmV3IFNraWxsSW52b2tlcihyZXF1ZXN0SGFuZGxlcik7XG4gICAgICAgIGF3YWl0IHRlc3RUdXJuKFxuICAgICAgICAgICAgaW52b2tlcixcbiAgICAgICAgICAgICdVOiAnLCBUZXN0SW5wdXQub2YoR2VuZXJhbENvbnRyb2xJbnRlbnQub2Yoe30pKSxcbiAgICAgICAgICAgICdBOicpO1xuXG5cbiAgICAgICAgZXhwZWN0KChyZXF1ZXN0SGFuZGxlci5nZXRTZXJpYWxpemFibGVDb250cm9sU3RhdGVzKCkuY3VzdG9tQ29udHJvbCBhcyBzdHJpbmdbXSlbMF0pLmV4aXN0LmFuZC5lcXVhbHMoJ3gnKTtcblxuICAgICAgICBhd2FpdCB0ZXN0VHVybihcbiAgICAgICAgICAgIGludm9rZXIsXG4gICAgICAgICAgICAnVTogJywgVGVzdElucHV0Lm9mKEdlbmVyYWxDb250cm9sSW50ZW50Lm9mKHt9KSksXG4gICAgICAgICAgICAnQTonKTtcblxuICAgICAgICBleHBlY3QoKHJlcXVlc3RIYW5kbGVyLmdldFNlcmlhbGl6YWJsZUNvbnRyb2xTdGF0ZXMoKS5jdXN0b21Db250cm9sIGFzIHN0cmluZ1tdKVswXSkuZXhpc3QuYW5kLmVxdWFscygneScpO1xuICAgIH0pO1xufSk7XG5cbmNsYXNzIEN1c3RvbVNlcmRlQ29udHJvbE1hbmFnZXIgZXh0ZW5kcyBDb250cm9sTWFuYWdlciB7XG5cbiAgICBjcmVhdGVDb250cm9sVHJlZShzdGF0ZTogYW55KTogQ29udHJvbCB7XG4gICAgICAgIHJldHVybiBuZXcgQ3VzdG9tU2VyZGVDb250cm9sKFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlkOiAnY3VzdG9tQ29udHJvbCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICB9XG59XG5cbmNsYXNzIEN1c3RvbVNlcmRlQ29udHJvbFN0YXRlIGltcGxlbWVudHMgQ29udHJvbFN0YXRlIHtcbiAgICB2YWx1ZTogU2V0PHN0cmluZz47XG5cbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZTogU2V0PHN0cmluZz4pIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbn1cblxuY2xhc3MgQ3VzdG9tU2VyZGVDb250cm9sIGV4dGVuZHMgQ29udHJvbCB7XG5cbiAgICBzdGF0ZTogQ3VzdG9tU2VyZGVDb250cm9sU3RhdGU7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcm9wczogQ29udHJvbFByb3BzLCBzdGF0ZT86IEN1c3RvbVNlcmRlQ29udHJvbFN0YXRlKSB7XG4gICAgICAgIHN1cGVyKHByb3BzLmlkKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlID8/IG5ldyBDdXN0b21TZXJkZUNvbnRyb2xTdGF0ZShuZXcgU2V0PHN0cmluZz4oKSk7XG4gICAgfVxuXG5cbiAgICBjYW5IYW5kbGUoaW5wdXQ6IENvbnRyb2xJbnB1dCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBhc3luYyBoYW5kbGUoaW5wdXQ6IENvbnRyb2xJbnB1dCwgcmVzdWx0QnVpbGRlcjogQ29udHJvbFJlc3VsdEJ1aWxkZXIpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUudmFsdWUuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZS52YWx1ZS5hZGQoJ3gnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnN0YXRlLnZhbHVlLnNpemUgPT09IDEgJiYgdGhpcy5zdGF0ZS52YWx1ZS5oYXMoJ3gnKSkge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZS52YWx1ZS5kZWxldGUoJ3gnKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUudmFsdWUuYWRkKCd5Jyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY2FuVGFrZUluaXRpYXRpdmUoaW5wdXQ6IENvbnRyb2xJbnB1dCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGFzeW5jIHRha2VJbml0aWF0aXZlKGlucHV0OiBDb250cm9sSW5wdXQsIHJlc3VsdEJ1aWxkZXI6IENvbnRyb2xSZXN1bHRCdWlsZGVyKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1ldGhvZCBub3QgaW1wbGVtZW50ZWQuXCIpO1xuICAgIH1cblxuICAgIGdldFNlcmlhbGl6YWJsZVN0YXRlKCk6IHN0cmluZ1tdIHtcbiAgICAgICAgLy8gcmVuZGVyIHRoZSBzZXQgYXMgYSBzaW1wbGUgbGlzdC5cbiAgICAgICAgcmV0dXJuIFsuLi4gdGhpcy5zdGF0ZS52YWx1ZS5rZXlzKCldO1xuICAgIH1cblxuICAgIHNldFNlcmlhbGl6YWJsZVN0YXRlKG9iajogc3RyaW5nW10pIHtcbiAgICAgICAgaWYgKG9iaiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyByZWZyZXNoZXMgdGhlIHNldCBmcm9tIHRoZSBzZXJpYWxpemVkIGFycmF5XG4gICAgICAgICAgICB0aGlzLnN0YXRlLnZhbHVlID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgZm9yIChjb25zdCB4IG9mIG9iaikge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUudmFsdWUuYWRkKHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVuZGVyQWN0KGFjdDogU3lzdGVtQWN0LCBpbnB1dDogQ29udHJvbElucHV0LCBidWlsZGVyOiBDb250cm9sUmVzcG9uc2VCdWlsZGVyKTogdm9pZCB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1ldGhvZCBub3QgaW1wbGVtZW50ZWQuXCIpO1xuICAgIH1cbn1cbiJdfQ==