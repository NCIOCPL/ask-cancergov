"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const mocha_1 = require("mocha");
const sinon_1 = tslib_1.__importDefault(require("sinon"));
const src_1 = require("../src");
const Control_1 = require("../src/controls/Control");
const ControlManager_1 = require("../src/controls/ControlManager");
const GeneralControlIntent_1 = require("../src/intents/GeneralControlIntent");
const TestingUtils_1 = require("../src/utils/testSupport/TestingUtils");
class RenderingDemoControl extends Control_1.Control {
    canHandle(input) {
        return true;
    }
    handle(input, resultBuilder) {
        // Adds three system acts to the result for demonstration purposes.
        /* The UnusableInputValueAct act includes some surface information (renderedReason) so that the act can use default render logic
         * This breaks the separation of Controller & View, but can be handy for simple cases. The simplest acts, e.g. ValueSetAct,
         * don't require any data for their defaults.
         *
         * Production code will likely not use this approach.
         */
        resultBuilder.addAct(new src_1.UnusableInputValueAct(this, { reasonCode: 'exampleReasonCode', value: '<dummy>', renderedReason: 'That input is unusable for reasons' }));
        /*
         * The next two are 'pure' acts that will be translated during the render-phase.
         * The InvalidValueAct is rendered by this Control in renderAct().  This is the most common approach.
         * The RequestValueAct is rendered by the ControlManager in render(). This is used when full control is necessary, such as to render two acts as a cohesive pair.
         */
        resultBuilder.addAct(new src_1.InvalidValueAct(this, { reasonCode: 'exampleReasonCode', value: '<dummy>' }));
        resultBuilder.addAct(new src_1.RequestValueAct(this, {}));
    }
    canTakeInitiative(input) {
        return false;
    }
    takeInitiative(input, resultBuilder) {
    }
    renderAct(act, input, responseBuilder) {
        if (act instanceof src_1.InvalidValueAct) {
            responseBuilder.addPromptFragment('The current value is invalid.'); // <<---- 'rendering by Control'. this is the most common approach
        }
        else {
            super.renderAct(act, input, responseBuilder); // <<---- super.renderAct delegates to act.render(). this is 'self-render'. see UnusableInputValueAct.render()
        }
    }
}
class RenderingDemoControlManager extends ControlManager_1.ControlManager {
    createControlTree(state, input) {
        return new RenderingDemoControl('root');
    }
    render(result, input, controlResponseBuilder) {
        for (const act of result.acts) {
            if (act instanceof src_1.RequestValueAct) {
                controlResponseBuilder.addPromptFragment('How many ducks?'); // <<---- 'render by ControlManager'.. this offers maximum power.
            }
            else {
                act.control.renderAct(act, input, controlResponseBuilder); // <<---- the general case is to 'render by Control'
            }
        }
    }
}
/**
 * Demonstrate standard ControlState object but with different Controls to handle them
 * the choice of control to use is by controlState.type and by registering the control types
 * with the UserInterface so that it can function as a control factory.
 */
mocha_1.suite("== Result rendering (renderingResult.spec.ts) ==", () => {
    mocha_1.test("Demonstrate SystemAct self-render & rendering overrides.", async () => {
        const requestHandler = new src_1.ControlHandler(new RenderingDemoControlManager());
        const invoker = new src_1.SkillInvoker(requestHandler);
        await TestingUtils_1.testTurn(invoker, 'U: ', TestingUtils_1.TestInput.of(GeneralControlIntent_1.GeneralControlIntent.of({})), 'A: Sorry, That input is unusable for reasons. The current value is invalid. How many ducks?');
    });
});
mocha_1.suite("== i18n overrides scenarios ==", () => {
    class MyControlManager extends ControlManager_1.ControlManager {
        createControlTree(state) {
            const topControl = new src_1.ContainerControl({ id: "root" });
            topControl.addChild(new src_1.DateControl({
                id: 'DateControl',
                validation: [src_1.DateControlValidations.PAST_DATE_ONLY]
            }));
            return topControl;
        }
    }
    beforeEach(() => {
        // set now to 2019-01-03
        sinon_1.default.useFakeTimers(new Date('2019-01-03T21:55:38.151Z'));
    });
    afterEach(() => {
        sinon_1.default.restore();
    });
    mocha_1.test("user-defined renderedReason getting translated and used with default InvalidValue prompt", async () => {
        const i18nOverride = {
            en: {
                translation: {
                    DATE_CONTROL_DEFAULT_PROMPT_VALIDATION_FAIL_PAST_DATE_ONLY: 'PAST DATE ONLY PLEASE'
                }
            }
        };
        const requestHandler = new src_1.ControlHandler(new MyControlManager({ i18nResources: i18nOverride }));
        const invoker = new src_1.SkillInvoker(requestHandler);
        await TestingUtils_1.testTurn(invoker, 'U: 2020', TestingUtils_1.TestInput.of(src_1.SingleValueControlIntent.of(src_1.AmazonBuiltInSlotType.DATE, { 'AMAZON.DATE': '2020' })), 'A: Sorry but that\'s not a valid date because PAST DATE ONLY PLEASE. What date?');
    });
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVuZGVyaW5nLnNwZWMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi90ZXN0L3JlbmRlcmluZy5zcGVjLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQWFBLGlDQUFvQztBQUNwQywwREFBMEI7QUFDMUIsZ0NBQTBQO0FBQzFQLHFEQUFrRDtBQUVsRCxtRUFBZ0U7QUFFaEUsOEVBQTJFO0FBQzNFLHdFQUE0RTtBQUc1RSxNQUFNLG9CQUFxQixTQUFRLGlCQUFPO0lBQ3RDLFNBQVMsQ0FBQyxLQUFtQjtRQUN6QixPQUFPLElBQUksQ0FBQztJQUNoQixDQUFDO0lBRUQsTUFBTSxDQUFDLEtBQW1CLEVBQUUsYUFBbUM7UUFFM0QsbUVBQW1FO1FBRW5FOzs7OztXQUtHO1FBQ0gsYUFBYSxDQUFDLE1BQU0sQ0FBQyxJQUFJLDJCQUFxQixDQUFDLElBQUksRUFBRSxFQUFDLFVBQVUsRUFBQyxtQkFBbUIsRUFBRSxLQUFLLEVBQUUsU0FBUyxFQUFFLGNBQWMsRUFBRSxvQ0FBb0MsRUFBQyxDQUFDLENBQUMsQ0FBQztRQUVoSzs7OztXQUlHO1FBRUgsYUFBYSxDQUFDLE1BQU0sQ0FBQyxJQUFJLHFCQUFlLENBQUMsSUFBSSxFQUFFLEVBQUMsVUFBVSxFQUFDLG1CQUFtQixFQUFFLEtBQUssRUFBRSxTQUFTLEVBQUMsQ0FBQyxDQUFDLENBQUM7UUFDcEcsYUFBYSxDQUFDLE1BQU0sQ0FBQyxJQUFJLHFCQUFlLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFFeEQsQ0FBQztJQUVELGlCQUFpQixDQUFDLEtBQW1CO1FBQ2pDLE9BQU8sS0FBSyxDQUFDO0lBQ2pCLENBQUM7SUFFRCxjQUFjLENBQUMsS0FBbUIsRUFBRSxhQUFtQztJQUN2RSxDQUFDO0lBRUQsU0FBUyxDQUFDLEdBQWMsRUFBRSxLQUFtQixFQUFFLGVBQXVDO1FBQ2xGLElBQUksR0FBRyxZQUFZLHFCQUFlLEVBQUM7WUFDL0IsZUFBZSxDQUFDLGlCQUFpQixD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Q0FBQyw4QkFBd0IsQ0FBQyxFQUFFLENBQUMsMkJBQXFCLENBQUMsSUFBSSxFQUFFLEVBQUMsYUFBYSxFQUFFLE1BQU0sRUFBRSxDQUFDLENBQUMsRUFDMUcsaUZBQWlGLENBQ3BGLENBQUM7SUFDTixDQUFDLENBQUMsQ0FBQztBQUNQLENBQUMsQ0FBQyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIENvcHlyaWdodCAyMDIwIEFtYXpvbi5jb20sIEluYy4gb3IgaXRzIGFmZmlsaWF0ZXMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpLlxuICogWW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogQSBjb3B5IG9mIHRoZSBMaWNlbnNlIGlzIGxvY2F0ZWQgYXRcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogb3IgaW4gdGhlIFwibGljZW5zZVwiIGZpbGUgYWNjb21wYW55aW5nIHRoaXMgZmlsZS4gVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkXG4gKiBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXJcbiAqIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nXG4gKiBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmltcG9ydCBpMThuZXh0IGZyb20gJ2kxOG5leHQnO1xuaW1wb3J0IHsgc3VpdGUsIHRlc3QgfSBmcm9tIFwibW9jaGFcIjtcbmltcG9ydCBzaW5vbiBmcm9tICdzaW5vbic7XG5pbXBvcnQgeyBDb250cm9sSGFuZGxlciwgQ29udHJvbFJlc3BvbnNlQnVpbGRlciwgSW52YWxpZFZhbHVlQWN0LCBSZXF1ZXN0VmFsdWVBY3QsIFNraWxsSW52b2tlciwgU3lzdGVtQWN0LCBVbnVzYWJsZUlucHV0VmFsdWVBY3QsIENvbnRhaW5lckNvbnRyb2wsIERhdGVDb250cm9sLCBEYXRlQ29udHJvbFZhbGlkYXRpb25zLCBTaW5nbGVWYWx1ZUNvbnRyb2xJbnRlbnQsIEFtYXpvbkJ1aWx0SW5TbG90VHlwZSB9IGZyb20gJy4uL3NyYyc7XG5pbXBvcnQgeyBDb250cm9sIH0gZnJvbSAnLi4vc3JjL2NvbnRyb2xzL0NvbnRyb2wnO1xuaW1wb3J0IHsgQ29udHJvbElucHV0IH0gZnJvbSAnLi4vc3JjL2NvbnRyb2xzL0NvbnRyb2xJbnB1dCc7XG5pbXBvcnQgeyBDb250cm9sTWFuYWdlciB9IGZyb20gJy4uL3NyYy9jb250cm9scy9Db250cm9sTWFuYWdlcic7XG5pbXBvcnQgeyBDb250cm9sUmVzdWx0LCBDb250cm9sUmVzdWx0QnVpbGRlciB9IGZyb20gJy4uL3NyYy9jb250cm9scy9Db250cm9sUmVzdWx0JztcbmltcG9ydCB7IEdlbmVyYWxDb250cm9sSW50ZW50IH0gZnJvbSAnLi4vc3JjL2ludGVudHMvR2VuZXJhbENvbnRyb2xJbnRlbnQnO1xuaW1wb3J0IHsgVGVzdElucHV0LCB0ZXN0VHVybiB9IGZyb20gJy4uL3NyYy91dGlscy90ZXN0U3VwcG9ydC9UZXN0aW5nVXRpbHMnO1xuXG5cbmNsYXNzIFJlbmRlcmluZ0RlbW9Db250cm9sIGV4dGVuZHMgQ29udHJvbCB7XG4gICAgY2FuSGFuZGxlKGlucHV0OiBDb250cm9sSW5wdXQpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaGFuZGxlKGlucHV0OiBDb250cm9sSW5wdXQsIHJlc3VsdEJ1aWxkZXI6IENvbnRyb2xSZXN1bHRCdWlsZGVyKTogdm9pZCB7XG5cbiAgICAgICAgLy8gQWRkcyB0aHJlZSBzeXN0ZW0gYWN0cyB0byB0aGUgcmVzdWx0IGZvciBkZW1vbnN0cmF0aW9uIHB1cnBvc2VzLlxuXG4gICAgICAgIC8qIFRoZSBVbnVzYWJsZUlucHV0VmFsdWVBY3QgYWN0IGluY2x1ZGVzIHNvbWUgc3VyZmFjZSBpbmZvcm1hdGlvbiAocmVuZGVyZWRSZWFzb24pIHNvIHRoYXQgdGhlIGFjdCBjYW4gdXNlIGRlZmF1bHQgcmVuZGVyIGxvZ2ljXG4gICAgICAgICAqIFRoaXMgYnJlYWtzIHRoZSBzZXBhcmF0aW9uIG9mIENvbnRyb2xsZXIgJiBWaWV3LCBidXQgY2FuIGJlIGhhbmR5IGZvciBzaW1wbGUgY2FzZXMuIFRoZSBzaW1wbGVzdCBhY3RzLCBlLmcuIFZhbHVlU2V0QWN0LFxuICAgICAgICAgKiBkb24ndCByZXF1aXJlIGFueSBkYXRhIGZvciB0aGVpciBkZWZhdWx0cy5cbiAgICAgICAgICpcbiAgICAgICAgICogUHJvZHVjdGlvbiBjb2RlIHdpbGwgbGlrZWx5IG5vdCB1c2UgdGhpcyBhcHByb2FjaC5cbiAgICAgICAgICovXG4gICAgICAgIHJlc3VsdEJ1aWxkZXIuYWRkQWN0KG5ldyBVbnVzYWJsZUlucHV0VmFsdWVBY3QodGhpcywge3JlYXNvbkNvZGU6J2V4YW1wbGVSZWFzb25Db2RlJywgdmFsdWU6ICc8ZHVtbXk+JywgcmVuZGVyZWRSZWFzb246ICdUaGF0IGlucHV0IGlzIHVudXNhYmxlIGZvciByZWFzb25zJ30pKTtcblxuICAgICAgICAvKlxuICAgICAgICAgKiBUaGUgbmV4dCB0d28gYXJlICdwdXJlJyBhY3RzIHRoYXQgd2lsbCBiZSB0cmFuc2xhdGVkIGR1cmluZyB0aGUgcmVuZGVyLXBoYXNlLlxuICAgICAgICAgKiBUaGUgSW52YWxpZFZhbHVlQWN0IGlzIHJlbmRlcmVkIGJ5IHRoaXMgQ29udHJvbCBpbiByZW5kZXJBY3QoKS4gIFRoaXMgaXMgdGhlIG1vc3QgY29tbW9uIGFwcHJvYWNoLlxuICAgICAgICAgKiBUaGUgUmVxdWVzdFZhbHVlQWN0IGlzIHJlbmRlcmVkIGJ5IHRoZSBDb250cm9sTWFuYWdlciBpbiByZW5kZXIoKS4gVGhpcyBpcyB1c2VkIHdoZW4gZnVsbCBjb250cm9sIGlzIG5lY2Vzc2FyeSwgc3VjaCBhcyB0byByZW5kZXIgdHdvIGFjdHMgYXMgYSBjb2hlc2l2ZSBwYWlyLlxuICAgICAgICAgKi9cblxuICAgICAgICByZXN1bHRCdWlsZGVyLmFkZEFjdChuZXcgSW52YWxpZFZhbHVlQWN0KHRoaXMsIHtyZWFzb25Db2RlOidleGFtcGxlUmVhc29uQ29kZScsIHZhbHVlOiAnPGR1bW15Pid9KSk7XG4gICAgICAgIHJlc3VsdEJ1aWxkZXIuYWRkQWN0KG5ldyBSZXF1ZXN0VmFsdWVBY3QodGhpcywge30pKTtcblxuICAgIH1cblxuICAgIGNhblRha2VJbml0aWF0aXZlKGlucHV0OiBDb250cm9sSW5wdXQpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHRha2VJbml0aWF0aXZlKGlucHV0OiBDb250cm9sSW5wdXQsIHJlc3VsdEJ1aWxkZXI6IENvbnRyb2xSZXN1bHRCdWlsZGVyKTogdm9pZCB7XG4gICAgfVxuXG4gICAgcmVuZGVyQWN0KGFjdDogU3lzdGVtQWN0LCBpbnB1dDogQ29udHJvbElucHV0LCByZXNwb25zZUJ1aWxkZXI6IENvbnRyb2xSZXNwb25zZUJ1aWxkZXIpOiB2b2lkIHtcbiAgICAgICAgaWYgKGFjdCBpbnN0YW5jZW9mIEludmFsaWRWYWx1ZUFjdCl7XG4gICAgICAgICAgICByZXNwb25zZUJ1aWxkZXIuYWRkUHJvbXB0RnJhZ21lbnQoJ1RoZSBjdXJyZW50IHZhbHVlIGlzIGludmFsaWQuJyk7IC8vIDw8LS0tLSAncmVuZGVyaW5nIGJ5IENvbnRyb2wnLiB0aGlzIGlzIHRoZSBtb3N0IGNvbW1vbiBhcHByb2FjaFxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3VwZXIucmVuZGVyQWN0KGFjdCwgaW5wdXQsIHJlc3BvbnNlQnVpbGRlcik7IC8vIDw8LS0tLSBzdXBlci5yZW5kZXJBY3QgZGVsZWdhdGVzIHRvIGFjdC5yZW5kZXIoKS4gdGhpcyBpcyAnc2VsZi1yZW5kZXInLiBzZWUgVW51c2FibGVJbnB1dFZhbHVlQWN0LnJlbmRlcigpXG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNsYXNzIFJlbmRlcmluZ0RlbW9Db250cm9sTWFuYWdlciBleHRlbmRzIENvbnRyb2xNYW5hZ2VyIHtcblxuICAgIGNyZWF0ZUNvbnRyb2xUcmVlKHN0YXRlPzogYW55LCBpbnB1dD86IENvbnRyb2xJbnB1dCk6IENvbnRyb2wge1xuICAgICAgICByZXR1cm4gbmV3IFJlbmRlcmluZ0RlbW9Db250cm9sKCdyb290Jyk7XG4gICAgfVxuXG4gICAgcmVuZGVyKHJlc3VsdDogQ29udHJvbFJlc3VsdCwgaW5wdXQ6IENvbnRyb2xJbnB1dCwgY29udHJvbFJlc3BvbnNlQnVpbGRlcjogQ29udHJvbFJlc3BvbnNlQnVpbGRlcik6IHZvaWQgfCBQcm9taXNlPHZvaWQ+IHtcblxuICAgICAgICBmb3IgKGNvbnN0IGFjdCBvZiByZXN1bHQuYWN0cykge1xuICAgICAgICAgICAgaWYgKGFjdCBpbnN0YW5jZW9mIFJlcXVlc3RWYWx1ZUFjdCl7XG4gICAgICAgICAgICAgICAgY29udHJvbFJlc3BvbnNlQnVpbGRlci5hZGRQcm9tcHRGcmFnbWVudCgnSG93IG1hbnkgZHVja3M/Jyk7IC8vIDw8LS0tLSAncmVuZGVyIGJ5IENvbnRyb2xNYW5hZ2VyJy4uIHRoaXMgb2ZmZXJzIG1heGltdW0gcG93ZXIuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhY3QuY29udHJvbC5yZW5kZXJBY3QoYWN0LCBpbnB1dCwgY29udHJvbFJlc3BvbnNlQnVpbGRlcik7IC8vIDw8LS0tLSB0aGUgZ2VuZXJhbCBjYXNlIGlzIHRvICdyZW5kZXIgYnkgQ29udHJvbCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuXG4vKipcbiAqIERlbW9uc3RyYXRlIHN0YW5kYXJkIENvbnRyb2xTdGF0ZSBvYmplY3QgYnV0IHdpdGggZGlmZmVyZW50IENvbnRyb2xzIHRvIGhhbmRsZSB0aGVtXG4gKiB0aGUgY2hvaWNlIG9mIGNvbnRyb2wgdG8gdXNlIGlzIGJ5IGNvbnRyb2xTdGF0ZS50eXBlIGFuZCBieSByZWdpc3RlcmluZyB0aGUgY29udHJvbCB0eXBlc1xuICogd2l0aCB0aGUgVXNlckludGVyZmFjZSBzbyB0aGF0IGl0IGNhbiBmdW5jdGlvbiBhcyBhIGNvbnRyb2wgZmFjdG9yeS5cbiAqL1xuc3VpdGUoXCI9PSBSZXN1bHQgcmVuZGVyaW5nIChyZW5kZXJpbmdSZXN1bHQuc3BlYy50cykgPT1cIiwgKCkgPT4ge1xuICAgIHRlc3QoXCJEZW1vbnN0cmF0ZSBTeXN0ZW1BY3Qgc2VsZi1yZW5kZXIgJiByZW5kZXJpbmcgb3ZlcnJpZGVzLlwiLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3RIYW5kbGVyID0gbmV3IENvbnRyb2xIYW5kbGVyKG5ldyBSZW5kZXJpbmdEZW1vQ29udHJvbE1hbmFnZXIoKSk7XG4gICAgICAgIGNvbnN0IGludm9rZXIgPSBuZXcgU2tpbGxJbnZva2VyKHJlcXVlc3RIYW5kbGVyKTtcbiAgICAgICAgYXdhaXQgdGVzdFR1cm4oXG4gICAgICAgICAgICBpbnZva2VyLFxuICAgICAgICAgICAgJ1U6ICcsIFRlc3RJbnB1dC5vZihHZW5lcmFsQ29udHJvbEludGVudC5vZih7fSkpLFxuICAgICAgICAgICAgJ0E6IFNvcnJ5LCBUaGF0IGlucHV0IGlzIHVudXNhYmxlIGZvciByZWFzb25zLiBUaGUgY3VycmVudCB2YWx1ZSBpcyBpbnZhbGlkLiBIb3cgbWFueSBkdWNrcz8nXG4gICAgICAgICk7XG4gICAgfSk7XG59KTtcblxuc3VpdGUoXCI9PSBpMThuIG92ZXJyaWRlcyBzY2VuYXJpb3MgPT1cIiwgKCkgPT4ge1xuXG4gICAgY2xhc3MgTXlDb250cm9sTWFuYWdlciBleHRlbmRzIENvbnRyb2xNYW5hZ2VyIHtcbiAgICAgICAgY3JlYXRlQ29udHJvbFRyZWUoc3RhdGU6IGFueSk6IENvbnRyb2wge1xuICAgICAgICAgICAgY29uc3QgdG9wQ29udHJvbCA9IG5ldyBDb250YWluZXJDb250cm9sKHsgaWQ6IFwicm9vdFwiIH0pO1xuICAgICAgICAgICAgdG9wQ29udHJvbC5hZGRDaGlsZChuZXcgRGF0ZUNvbnRyb2woXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBpZDogJ0RhdGVDb250cm9sJyxcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogW0RhdGVDb250cm9sVmFsaWRhdGlvbnMuUEFTVF9EQVRFX09OTFldXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKSk7XG5cbiAgICAgICAgICAgIHJldHVybiB0b3BDb250cm9sO1xuICAgICAgICB9XG4gICAgfVxuICAgIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgICAgICAvLyBzZXQgbm93IHRvIDIwMTktMDEtMDNcbiAgICAgICAgc2lub24udXNlRmFrZVRpbWVycyhuZXcgRGF0ZSgnMjAxOS0wMS0wM1QyMTo1NTozOC4xNTFaJykpO1xuICAgIH0pO1xuXG4gICAgYWZ0ZXJFYWNoKCgpID0+IHtcbiAgICAgICAgc2lub24ucmVzdG9yZSgpO1xuICAgIH0pO1xuICAgIHRlc3QoXCJ1c2VyLWRlZmluZWQgcmVuZGVyZWRSZWFzb24gZ2V0dGluZyB0cmFuc2xhdGVkIGFuZCB1c2VkIHdpdGggZGVmYXVsdCBJbnZhbGlkVmFsdWUgcHJvbXB0XCIsIGFzeW5jICgpID0+IHtcblxuICAgICAgICBjb25zdCBpMThuT3ZlcnJpZGUgPSB7XG4gICAgICAgICAgICBlbjoge1xuICAgICAgICAgICAgICAgIHRyYW5zbGF0aW9uOiB7XG4gICAgICAgICAgICAgICAgICAgIERBVEVfQ09OVFJPTF9ERUZBVUxUX1BST01QVF9WQUxJREFUSU9OX0ZBSUxfUEFTVF9EQVRFX09OTFk6ICdQQVNUIERBVEUgT05MWSBQTEVBU0UnXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IHJlcXVlc3RIYW5kbGVyID0gbmV3IENvbnRyb2xIYW5kbGVyKG5ldyBNeUNvbnRyb2xNYW5hZ2VyKHsgaTE4blJlc291cmNlczogaTE4bk92ZXJyaWRlIH0pKTtcbiAgICAgICAgY29uc3QgaW52b2tlciA9IG5ldyBTa2lsbEludm9rZXIocmVxdWVzdEhhbmRsZXIpO1xuICAgICAgICBhd2FpdCB0ZXN0VHVybihcbiAgICAgICAgICAgIGludm9rZXIsXG4gICAgICAgICAgICAnVTogMjAyMCcsIFRlc3RJbnB1dC5vZihTaW5nbGVWYWx1ZUNvbnRyb2xJbnRlbnQub2YoQW1hem9uQnVpbHRJblNsb3RUeXBlLkRBVEUsIHsnQU1BWk9OLkRBVEUnOiAnMjAyMCcgfSkpLFxuICAgICAgICAgICAgJ0E6IFNvcnJ5IGJ1dCB0aGF0XFwncyBub3QgYSB2YWxpZCBkYXRlIGJlY2F1c2UgUEFTVCBEQVRFIE9OTFkgUExFQVNFLiBXaGF0IGRhdGU/J1xuICAgICAgICApO1xuICAgIH0pO1xufSk7Il19