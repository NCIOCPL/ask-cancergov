"use strict";
/*
 * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const chai_1 = require("chai");
const _ = tslib_1.__importStar(require("lodash"));
const mocha_1 = require("mocha");
const path_1 = require("path");
const sinon_1 = tslib_1.__importDefault(require("sinon"));
const src_1 = require("../../src");
const interactionModelForTest_1 = require("./interactionModelForTest");
const TEST_INTENT = {
    name: "CustomIntent",
    slots: [
        {
            name: "PhoneNumber",
            type: "AMAZON.PhoneNumber"
        }
    ],
    samples: [
        "{PhoneNumber}",
        "give me your {PhoneNumber}"
    ]
};
const TEST_SLOT_TYPE_VALUE = {
    id: 'TEST_ID',
    name: {
        value: 'TEST_VALUE',
        synonyms: [
            'TEST_SYNONYMS'
        ]
    }
};
const TEST_SLOT_TYPE = {
    name: 'TEST',
    values: [
        TEST_SLOT_TYPE_VALUE,
    ]
};
const TEST_DIALOG_INTENT = {
    name: 'TEST_DIALOG_INTENT_NAME',
    slots: [
        {
            name: 'TEST_SLOT_NAME',
            type: 'TEST_SLOT_TYPE'
        }
    ]
};
const TEST_DELEGATION_STRATEGY = 'ALWAYS';
const TEST_INVOCATION_NAME = 'TEST_INVOCATION_NAME';
const TEST_PROMPT = {
    id: 'TEST_ID',
    variations: [{ type: 'SSML', value: 'TEST_VALUE' }]
};
mocha_1.suite('InteractionModel Generator tests', () => {
    const mockFilePath = path_1.join(__dirname, '..', 'mock', 'inputInteractionModel.json');
    afterEach(() => {
        sinon_1.default.restore();
    });
    mocha_1.suite('add Intents tests', () => {
        mocha_1.test('addIntent should successfully add single intent to IM', () => {
            const interactionModel = new src_1.InteractionModelGenerator()
                .addIntents(TEST_INTENT)
                .withInvocationName(TEST_INVOCATION_NAME)
                .build();
            const expectedInteractionModel = {
                interactionModel: {
                    languageModel: {
                        invocationName: TEST_INVOCATION_NAME,
                        intents: [
                            TEST_INTENT
                        ],
                        types: []
                    },
                    prompts: []
                },
            };
            chai_1.expect(interactionModel).deep.equal(expectedInteractionModel);
        });
        mocha_1.test('addIntent should not add duplicate intent', () => {
            const interactionModel = new src_1.InteractionModelGenerator()
                .addIntents(TEST_INTENT, TEST_INTENT)
                .withInvocationName(TEST_INVOCATION_NAME)
                .build();
            const expectedInteractionModel = {
                interactionModel: {
                    languageModel: {
                        invocationName: TEST_INVOCATION_NAME,
                        intents: [
                            TEST_INTENT
                        ],
                        types: []
                    },
                    prompts: []
                },
            };
            chai_1.expect(interactionModel).deep.equal(expectedInteractionModel);
        });
        mocha_1.test('addIntents should throw error when an intent is defined more than once', () => {
            const testIntentWithSameName = _.cloneDeep(TEST_INTENT);
            testIntentWithSameName.samples = [];
            try {
                const interactionModel = new src_1.InteractionModelGenerator()
                    .addIntents(TEST_INTENT, testIntentWithSameName)
                    .withInvocationName('test')
                    .build();
            }
            catch (e) {
                chai_1.expect(e.message).equal(`Intent ${testIntentWithSameName.name} is defined more than once and the definitions are not identical.`);
                return;
            }
            chai_1.expect.fail('should throw error');
        });
    });
    mocha_1.suite('add slotTypes tests', () => {
        mocha_1.test('addSlotTypes should successfully add single slotType to IM', () => {
            const interactionModel = new src_1.InteractionModelGenerator()
                .addOrMergeSlotTypes(TEST_SLOT_TYPE)
                .withInvocationName(TEST_INVOCATION_NAME)
                .build();
            const expectedInteractionModel = {
                interactionModel: {
                    languageModel: {
                        invocationName: TEST_INVOCATION_NAME,
                        intents: [],
                        types: [TEST_SLOT_TYPE]
                    },
                    prompts: []
                },
            };
            chai_1.expect(interactionModel).deep.equal(expectedInteractionModel);
        });
        mocha_1.test('addSlotTypes should not add duplicate slotType to IM', () => {
            const interactionModel = new src_1.InteractionModelGenerator()
                .addOrMergeSlotTypes(TEST_SLOT_TYPE, TEST_SLOT_TYPE)
                .withInvocationName(TEST_INVOCATION_NAME)
                .build();
            const expectedInteractionModel = {
                interactionModel: {
                    languageModel: {
                        invocationName: TEST_INVOCATION_NAME,
                        intents: [],
                        types: [TEST_SLOT_TYPE]
                    },
                    prompts: []
                },
            };
            chai_1.expect(interactionModel).deep.equal(expectedInteractionModel);
        });
        mocha_1.test('addSlotTypes should throw error when two slotTypeValue has same id but different name.value', () => {
            const modifiedTestSlotType = _.cloneDeep(TEST_SLOT_TYPE);
            modifiedTestSlotType.values[0].name.value = '';
            try {
                const interactionModel = new src_1.InteractionModelGenerator()
                    .addOrMergeSlotTypes(TEST_SLOT_TYPE, modifiedTestSlotType)
                    .withInvocationName(TEST_INVOCATION_NAME)
                    .build();
            }
            catch (e) {
                chai_1.expect(e.message).equal(`Cannot merge slot type ${TEST_SLOT_TYPE.name}, as the value ${JSON.stringify(modifiedTestSlotType.values[0])} and ${JSON.stringify(TEST_SLOT_TYPE.values[0])} has the same id but different name.value.`);
                return;
            }
            chai_1.expect.fail('should throw error');
        });
        mocha_1.test('addSlotTypes should throw error when two slotTypeValue has same name.value but different id', () => {
            const modifiedTestSlotType = _.cloneDeep(TEST_SLOT_TYPE);
            modifiedTestSlotType.values[0].id = '';
            try {
                const interactionModel = new src_1.InteractionModelGenerator()
                    .addOrMergeSlotTypes(TEST_SLOT_TYPE, modifiedTestSlotType)
                    .withInvocationName(TEST_INVOCATION_NAME)
                    .build();
            }
            catch (e) {
                chai_1.expect(e.message).equal(`Cannot merge slot type ${TEST_SLOT_TYPE.name}, as the value ${JSON.stringify(modifiedTestSlotType.values[0])} and ${JSON.stringify(TEST_SLOT_TYPE.values[0])} has the same name.value but different id.`);
                return;
            }
            chai_1.expect.fail('should throw error');
        });
        mocha_1.test('addSlotTypes should be able to merge synonyms', () => {
            const newSlotType = _.cloneDeep(TEST_SLOT_TYPE);
            newSlotType.values[0].name.synonyms = ['new synonym'];
            const interactionModel = new src_1.InteractionModelGenerator()
                .addOrMergeSlotTypes(TEST_SLOT_TYPE, newSlotType)
                .withInvocationName(TEST_INVOCATION_NAME)
                .build();
            const expectedInteractionModel = {
                interactionModel: {
                    languageModel: {
                        invocationName: TEST_INVOCATION_NAME,
                        intents: [],
                        types: [{
                                name: 'TEST',
                                values: [
                                    {
                                        id: 'TEST_ID',
                                        name: {
                                            value: 'TEST_VALUE',
                                            synonyms: [
                                                'TEST_SYNONYMS',
                                                'new synonym'
                                            ]
                                        }
                                    },
                                ]
                            }]
                    },
                    prompts: []
                },
            };
            chai_1.expect(interactionModel).deep.equal(expectedInteractionModel);
        });
        mocha_1.test('addValuesToSlotType should throw error when the slotName is not exist', () => {
            try {
                const interactionModel = new src_1.InteractionModelGenerator()
                    .addValuesToSlotType('Name', TEST_SLOT_TYPE_VALUE)
                    .withInvocationName(TEST_INVOCATION_NAME)
                    .build();
            }
            catch (e) {
                chai_1.expect(e.message).equal(`SlotType Name is not defined.`);
                return;
            }
            chai_1.expect.fail('should throw error');
        });
        mocha_1.test('addValuesToSlotType should successfully add value to exist slotType', () => {
            const extraSlotValue = {
                id: 'EXTRA_ID',
                name: {
                    value: 'EXTRA_VALUE',
                    synonyms: [
                        'EXTRA_SYNONYMS'
                    ]
                }
            };
            const interactionModel = new src_1.InteractionModelGenerator()
                .addOrMergeSlotTypes(TEST_SLOT_TYPE)
                .addValuesToSlotType(TEST_SLOT_TYPE.name, extraSlotValue)
                .withInvocationName(TEST_INVOCATION_NAME)
                .build();
            const expectedInteractionModel = {
                interactionModel: {
                    languageModel: {
                        invocationName: TEST_INVOCATION_NAME,
                        intents: [],
                        types: [{
                                name: 'TEST',
                                values: [
                                    TEST_SLOT_TYPE_VALUE,
                                    extraSlotValue
                                ]
                            }]
                    },
                    prompts: []
                },
            };
            chai_1.expect(interactionModel).deep.equal(expectedInteractionModel);
        });
    });
    mocha_1.suite('add dialogIntents tests', () => {
        mocha_1.test('addDialogIntents should successfully add single intent to IM', () => {
            const interactionModel = new src_1.InteractionModelGenerator()
                .addDialogIntents(TEST_DIALOG_INTENT)
                .withInvocationName(TEST_INVOCATION_NAME)
                .build();
            const expectedInteractionModel = {
                interactionModel: {
                    languageModel: {
                        invocationName: TEST_INVOCATION_NAME,
                        intents: [],
                        types: []
                    },
                    dialog: {
                        intents: [TEST_DIALOG_INTENT]
                    },
                    prompts: []
                },
            };
            chai_1.expect(interactionModel).deep.equal(expectedInteractionModel);
        });
        mocha_1.test('addDialogIntents should not add duplicate dialogIntent', () => {
            const interactionModel = new src_1.InteractionModelGenerator()
                .addDialogIntents(TEST_DIALOG_INTENT, TEST_DIALOG_INTENT)
                .withInvocationName(TEST_INVOCATION_NAME)
                .build();
            const expectedInteractionModel = {
                interactionModel: {
                    languageModel: {
                        invocationName: TEST_INVOCATION_NAME,
                        intents: [],
                        types: []
                    },
                    dialog: {
                        intents: [TEST_DIALOG_INTENT]
                    },
                    prompts: []
                },
            };
            chai_1.expect(interactionModel).deep.equal(expectedInteractionModel);
        });
        mocha_1.test('addDialogIntents should throw error when an dialogIntent is defined more than once', () => {
            const testIntentWithSameName = _.cloneDeep(TEST_DIALOG_INTENT);
            testIntentWithSameName.slots = [];
            try {
                const interactionModel = new src_1.InteractionModelGenerator()
                    .addDialogIntents(TEST_DIALOG_INTENT, testIntentWithSameName)
                    .withInvocationName('test')
                    .build();
            }
            catch (e) {
                chai_1.expect(e.message).equal(`DialogIntent ${testIntentWithSameName.name} is defined more than once and the definitions are not identical.`);
                return;
            }
            chai_1.expect.fail('should throw error');
        });
    });
    mocha_1.suite('add prompts tests', () => {
        mocha_1.test('addPrompts should successfully add single prompt to IM', () => {
            const interactionModel = new src_1.InteractionModelGenerator()
                .addPrompts(TEST_PROMPT)
                .withInvocationName(TEST_INVOCATION_NAME)
                .build();
            const expectedInteractionModel = {
                interactionModel: {
                    languageModel: {
                        invocationName: TEST_INVOCATION_NAME,
                        intents: [],
                        types: []
                    },
                    prompts: [TEST_PROMPT]
                },
            };
            chai_1.expect(interactionModel).deep.equal(expectedInteractionModel);
        });
        mocha_1.test('addPrompts should not add duplicate prompt', () => {
            const interactionModel = new src_1.InteractionModelGenerator()
                .addPrompts(TEST_PROMPT, TEST_PROMPT)
                .withInvocationName(TEST_INVOCATION_NAME)
                .build();
            const expectedInteractionModel = {
                interactionModel: {
                    languageModel: {
                        invocationName: TEST_INVOCATION_NAME,
                        intents: [],
                        types: []
                    },
                    prompts: [TEST_PROMPT]
                },
            };
            chai_1.expect(interactionModel).deep.equal(expectedInteractionModel);
        });
        mocha_1.test('addPrompts should throw error when an prompt is defined more than once', () => {
            const testPromptWithSameId = _.cloneDeep(TEST_PROMPT);
            testPromptWithSameId.variations = [];
            try {
                const interactionModel = new src_1.InteractionModelGenerator()
                    .addPrompts(TEST_PROMPT, testPromptWithSameId)
                    .withInvocationName('test')
                    .build();
            }
            catch (e) {
                chai_1.expect(e.message).equal(`Prompt with id ${TEST_PROMPT.id} is defined more than once and the definitions are not identical.`);
                return;
            }
            chai_1.expect.fail('should throw error');
        });
    });
    mocha_1.suite('High level function tests', () => {
        mocha_1.test('should be able to throw error when input file not exist', () => {
            const invalidFilePath = path_1.join(__dirname, 'invalidFile.json');
            try {
                const interactionModel = new src_1.InteractionModelGenerator().loadFromFile(invalidFilePath).build();
            }
            catch (e) {
                chai_1.expect(e.message).equal('Input path is not valid.');
                return;
            }
            chai_1.expect.fail('should throw error');
        });
        mocha_1.test('should be able to generate InteractionModel by reading exist models', () => {
            const interactionModel = new src_1.InteractionModelGenerator().loadFromFile(mockFilePath).build();
            chai_1.expect(interactionModel).deep.equal(interactionModelForTest_1.jsonProvider.loadMockInputFile());
        });
        mocha_1.test('should be able to add custom Intent, SlotTypes, DialogIntents, DelegationStrategy, InvocationName by using function chain', () => {
            const interactionModel = new src_1.InteractionModelGenerator()
                .addIntents(TEST_INTENT)
                .addOrMergeSlotTypes(TEST_SLOT_TYPE)
                .addDialogIntents(TEST_DIALOG_INTENT)
                .addDelegationStrategy(TEST_DELEGATION_STRATEGY)
                .withInvocationName(TEST_INVOCATION_NAME)
                .build();
            const expectedInteractionModel = {
                interactionModel: {
                    languageModel: {
                        intents: [
                            TEST_INTENT
                        ],
                        types: [TEST_SLOT_TYPE],
                        invocationName: TEST_INVOCATION_NAME
                    },
                    dialog: {
                        delegationStrategy: TEST_DELEGATION_STRATEGY,
                        intents: [TEST_DIALOG_INTENT]
                    },
                    prompts: []
                }
            };
            chai_1.expect(interactionModel).deep.equal(expectedInteractionModel);
        });
    });
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW50ZXJhY3Rpb25Nb2RlbEdlbmVyYXRvci5zcGVjLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vdGVzdC9pbnRlcmFjdGlvbk1vZGVsR2VuZXJhdG9yVGVzdHMvaW50ZXJhY3Rpb25Nb2RlbEdlbmVyYXRvci5zcGVjLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTs7Ozs7Ozs7Ozs7R0FXRzs7O0FBR0gsK0JBQThCO0FBQzlCLGtEQUE0QjtBQUM1QixpQ0FBb0M7QUFDcEMsK0JBQTRCO0FBQzVCLDBEQUEwQjtBQUMxQixtQ0FBc0Q7QUFDdEQsdUVBQXlEO0FBU3pELE1BQU0sV0FBVyxHQUFXO0lBQ3hCLElBQUksRUFBRSxjQUFjO0lBQ3BCLEtBQUssRUFBRTtRQUNIO1lBQ0ksSUFBSSxFQUFFLGFBQWE7WUFDbkIsSUFBSSxFQUFFLG9CQUFvQjtTQUM3QjtLQUNKO0lBQ0QsT0FBTyxFQUFFO1FBQ0wsZUFBZTtRQUNmLDRCQUE0QjtLQUMvQjtDQUNKLENBQUM7QUFDRixNQUFNLG9CQUFvQixHQUFHO0lBQ3pCLEVBQUUsRUFBRSxTQUFTO0lBQ2IsSUFBSSxFQUFFO1FBQ0YsS0FBSyxFQUFFLFlBQVk7UUFDbkIsUUFBUSxFQUFFO1lBQ04sZUFBZTtTQUNsQjtLQUNKO0NBRUosQ0FBQztBQUVGLE1BQU0sY0FBYyxHQUFhO0lBQzdCLElBQUksRUFBRSxNQUFNO0lBQ1osTUFBTSxFQUFFO1FBQ0osb0JBQW9CO0tBQ3ZCO0NBQ0osQ0FBQztBQUdGLE1BQU0sa0JBQWtCLEdBQWlCO0lBQ3JDLElBQUksRUFBRSx5QkFBeUI7SUFDL0IsS0FBSyxFQUFFO1FBQ0g7WUFDSSxJQUFJLEVBQUUsZ0JBQWdCO1lBQ3RCLElBQUksRUFBRSxnQkFBZ0I7U0FDekI7S0FDSjtDQUNKLENBQUM7QUFFRixNQUFNLHdCQUF3QixHQUEyQixRQUFRLENBQUM7QUFDbEUsTUFBTSxvQkFBb0IsR0FBVyxzQkFBc0IsQ0FBQztBQUU1RCxNQUFNLFdBQVcsR0FB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Q0FBQyxZQUFZLENBQUMsWUFBWSxDQUFDLENBQUMsS0FBSyxFQUFFLENBQUM7WUFDNUYsYUFBTSxDQUFDLGdCQUFnQixDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxzQ0FBWSxDQUFDLGlCQUFpQixFQUFFLENBQUMsQ0FBQztRQUMxRSxDQUFDLENBQUMsQ0FBQztRQUVILFlBQUksQ0FBQywySEFBMkgsRUFBRSxHQUFHLEVBQUU7WUFFbkksTUFBTSxnQkFBZ0IsR0FBeUIsSUFBSSwrQkFBeUIsRUFBRTtpQkFDekUsVUFBVSxDQUFDLFdBQVcsQ0FBQztpQkFDdkIsbUJBQW1CLENBQUMsY0FBYyxDQUFDO2lCQUNuQyxnQkFBZ0IsQ0FBQyxrQkFBa0IsQ0FBQztpQkFDcEMscUJBQXFCLENBQUMsd0JBQXdCLENBQUM7aUJBQy9DLGtCQUFrQixDQUFDLG9CQUFvQixDQUFDO2lCQUN4QyxLQUFLLEVBQUUsQ0FBQztZQUNiLE1BQU0sd0JBQXdCLEdBQXlCO2dCQUNuRCxnQkFBZ0IsRUFBRTtvQkFDZCxhQUFhLEVBQUU7d0JBQ1gsT0FBTyxFQUFFOzRCQUNMLFdBQVc7eUJBQ2Q7d0JBQ0QsS0FBSyxFQUFFLENBQUMsY0FBYyxDQUFDO3dCQUN2QixjQUFjLEVBQUUsb0JBQW9CO3FCQUN2QztvQkFDRCxNQUFNLEVBQUU7d0JBQ0osa0JBQWtCLEVBQUUsd0JBQXdCO3dCQUM1QyxPQUFPLEVBQUUsQ0FBQyxrQkFBa0IsQ0FBQztxQkFDaEM7b0JBQ0QsT0FBTyxFQUFFLEVBQUU7aUJBQ2Q7YUFDSixDQUFDO1lBQ0YsYUFBTSxDQUFDLGdCQUFnQixDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyx3QkFBd0IsQ0FBQyxDQUFDO1FBQ2xFLENBQUMsQ0FBQyxDQUFDO0lBQ1AsQ0FBQyxDQUFDLENBQUM7QUFHUCxDQUFDLENBQUMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBbWF6b24uY29tLCBJbmMuIG9yIGl0cyBhZmZpbGlhdGVzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKS5cbiAqIFlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIEEgY29weSBvZiB0aGUgTGljZW5zZSBpcyBsb2NhdGVkIGF0XG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIG9yIGluIHRoZSBcImxpY2Vuc2VcIiBmaWxlIGFjY29tcGFueWluZyB0aGlzIGZpbGUuIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZFxuICogb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyXG4gKiBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZ1xuICogcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IHYxIH0gZnJvbSAnYXNrLXNtYXBpLW1vZGVsJztcbmltcG9ydCB7IGV4cGVjdCB9IGZyb20gXCJjaGFpXCI7XG5pbXBvcnQgKiBhcyBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgeyBzdWl0ZSwgdGVzdCB9IGZyb20gJ21vY2hhJztcbmltcG9ydCB7IGpvaW4gfSBmcm9tICdwYXRoJztcbmltcG9ydCBzaW5vbiBmcm9tICdzaW5vbic7XG5pbXBvcnQgeyBJbnRlcmFjdGlvbk1vZGVsR2VuZXJhdG9yIH0gZnJvbSAnLi4vLi4vc3JjJztcbmltcG9ydCB7IGpzb25Qcm92aWRlciB9IGZyb20gJy4vaW50ZXJhY3Rpb25Nb2RlbEZvclRlc3QnO1xuXG5pbXBvcnQgSW50ZW50ID0gdjEuc2tpbGwuaW50ZXJhY3Rpb25Nb2RlbC5JbnRlbnQ7XG5pbXBvcnQgU2xvdFR5cGUgPSB2MS5za2lsbC5pbnRlcmFjdGlvbk1vZGVsLlNsb3RUeXBlO1xuaW1wb3J0IERpYWxvZ0ludGVudCA9IHYxLnNraWxsLmludGVyYWN0aW9uTW9kZWwuRGlhbG9nSW50ZW50cztcbmltcG9ydCBEZWxlZ2F0aW9uU3RyYXRlZ3lUeXBlID0gdjEuc2tpbGwuaW50ZXJhY3Rpb25Nb2RlbC5EZWxlZ2F0aW9uU3RyYXRlZ3lUeXBlO1xuaW1wb3J0IEludGVyYWN0aW9uTW9kZWxEYXRhID0gdjEuc2tpbGwuaW50ZXJhY3Rpb25Nb2RlbC5JbnRlcmFjdGlvbk1vZGVsRGF0YTtcbmltcG9ydCBQcm9tcHQgPSB2MS5za2lsbC5pbnRlcmFjdGlvbk1vZGVsLlByb21wdDtcblxuY29uc3QgVEVTVF9JTlRFTlQ6IEludGVudCA9IHtcbiAgICBuYW1lOiBcIkN1c3RvbUludGVudFwiLFxuICAgIHNsb3RzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6IFwiUGhvbmVOdW1iZXJcIixcbiAgICAgICAgICAgIHR5cGU6IFwiQU1BWk9OLlBob25lTnVtYmVyXCJcbiAgICAgICAgfVxuICAgIF0sXG4gICAgc2FtcGxlczogW1xuICAgICAgICBcIntQaG9uZU51bWJlcn1cIixcbiAgICAgICAgXCJnaXZlIG1lIHlvdXIge1Bob25lTnVtYmVyfVwiXG4gICAgXVxufTtcbmNvbnN0IFRFU1RfU0xPVF9UWVBFX1ZBTFVFID0ge1xuICAgIGlkOiAnVEVTVF9JRCcsXG4gICAgbmFtZToge1xuICAgICAgICB2YWx1ZTogJ1RFU1RfVkFMVUUnLFxuICAgICAgICBzeW5vbnltczogW1xuICAgICAgICAgICAgJ1RFU1RfU1lOT05ZTVMnXG4gICAgICAgIF1cbiAgICB9XG5cbn07XG5cbmNvbnN0IFRFU1RfU0xPVF9UWVBFOiBTbG90VHlwZSA9IHtcbiAgICBuYW1lOiAnVEVTVCcsXG4gICAgdmFsdWVzOiBbXG4gICAgICAgIFRFU1RfU0xPVF9UWVBFX1ZBTFVFLFxuICAgIF1cbn07XG5cblxuY29uc3QgVEVTVF9ESUFMT0dfSU5URU5UOiBEaWFsb2dJbnRlbnQgPSB7XG4gICAgbmFtZTogJ1RFU1RfRElBTE9HX0lOVEVOVF9OQU1FJyxcbiAgICBzbG90czogW1xuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnVEVTVF9TTE9UX05BTUUnLFxuICAgICAgICAgICAgdHlwZTogJ1RFU1RfU0xPVF9UWVBFJ1xuICAgICAgICB9XG4gICAgXVxufTtcblxuY29uc3QgVEVTVF9ERUxFR0FUSU9OX1NUUkFURUdZOiBEZWxlZ2F0aW9uU3RyYXRlZ3lUeXBlID0gJ0FMV0FZUyc7XG5jb25zdCBURVNUX0lOVk9DQVRJT05fTkFNRTogc3RyaW5nID0gJ1RFU1RfSU5WT0NBVElPTl9OQU1FJztcblxuY29uc3QgVEVTVF9QUk9NUFQ6IFByb21wdCA9IHtcbiAgICBpZDogJ1RFU1RfSUQnLFxuICAgIHZhcmlhdGlvbnM6IFt7IHR5cGU6ICdTU01MJywgdmFsdWU6ICdURVNUX1ZBTFVFJyB9XVxufTtcblxuXG5zdWl0ZSgnSW50ZXJhY3Rpb25Nb2RlbCBHZW5lcmF0b3IgdGVzdHMnLCAoKSA9PiB7XG4gICAgY29uc3QgbW9ja0ZpbGVQYXRoID0gam9pbihfX2Rpcm5hbWUsICcuLicsICdtb2NrJywgJ2lucHV0SW50ZXJhY3Rpb25Nb2RlbC5qc29uJyk7XG5cbiAgICBhZnRlckVhY2goKCkgPT4ge1xuICAgICAgICBzaW5vbi5yZXN0b3JlKCk7XG4gICAgfSk7XG4gICAgc3VpdGUoJ2FkZCBJbnRlbnRzIHRlc3RzJywgKCkgPT4ge1xuICAgICAgICB0ZXN0KCdhZGRJbnRlbnQgc2hvdWxkIHN1Y2Nlc3NmdWxseSBhZGQgc2luZ2xlIGludGVudCB0byBJTScsICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGludGVyYWN0aW9uTW9kZWwgPSBuZXcgSW50ZXJhY3Rpb25Nb2RlbEdlbmVyYXRvcigpXG4gICAgICAgICAgICAgICAgLmFkZEludGVudHMoVEVTVF9JTlRFTlQpXG4gICAgICAgICAgICAgICAgLndpdGhJbnZvY2F0aW9uTmFtZShURVNUX0lOVk9DQVRJT05fTkFNRSlcbiAgICAgICAgICAgICAgICAuYnVpbGQoKTtcblxuICAgICAgICAgICAgY29uc3QgZXhwZWN0ZWRJbnRlcmFjdGlvbk1vZGVsOiBJbnRlcmFjdGlvbk1vZGVsRGF0YSA9IHtcbiAgICAgICAgICAgICAgICBpbnRlcmFjdGlvbk1vZGVsOiB7XG4gICAgICAgICAgICAgICAgICAgIGxhbmd1YWdlTW9kZWw6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludm9jYXRpb25OYW1lOiBURVNUX0lOVk9DQVRJT05fTkFNRSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVudHM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBURVNUX0lOVEVOVFxuICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVzOiBbXVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBwcm9tcHRzOiBbXVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBleHBlY3QoaW50ZXJhY3Rpb25Nb2RlbCkuZGVlcC5lcXVhbChleHBlY3RlZEludGVyYWN0aW9uTW9kZWwpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0ZXN0KCdhZGRJbnRlbnQgc2hvdWxkIG5vdCBhZGQgZHVwbGljYXRlIGludGVudCcsICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGludGVyYWN0aW9uTW9kZWwgPSBuZXcgSW50ZXJhY3Rpb25Nb2RlbEdlbmVyYXRvcigpXG4gICAgICAgICAgICAgICAgLmFkZEludGVudHMoVEVTVF9JTlRFTlQsIFRFU1RfSU5URU5UKVxuICAgICAgICAgICAgICAgIC53aXRoSW52b2NhdGlvbk5hbWUoVEVTVF9JTlZPQ0FUSU9OX05BTUUpXG4gICAgICAgICAgICAgICAgLmJ1aWxkKCk7XG5cbiAgICAgICAgICAgIGNvbnN0IGV4cGVjdGVkSW50ZXJhY3Rpb25Nb2RlbDogSW50ZXJhY3Rpb25Nb2RlbERhdGEgPSB7XG4gICAgICAgICAgICAgICAgaW50ZXJhY3Rpb25Nb2RlbDoge1xuICAgICAgICAgICAgICAgICAgICBsYW5ndWFnZU1vZGVsOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnZvY2F0aW9uTmFtZTogVEVTVF9JTlZPQ0FUSU9OX05BTUUsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlbnRzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgVEVTVF9JTlRFTlRcbiAgICAgICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlczogW11cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgcHJvbXB0czogW11cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgZXhwZWN0KGludGVyYWN0aW9uTW9kZWwpLmRlZXAuZXF1YWwoZXhwZWN0ZWRJbnRlcmFjdGlvbk1vZGVsKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGVzdCgnYWRkSW50ZW50cyBzaG91bGQgdGhyb3cgZXJyb3Igd2hlbiBhbiBpbnRlbnQgaXMgZGVmaW5lZCBtb3JlIHRoYW4gb25jZScsICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRlc3RJbnRlbnRXaXRoU2FtZU5hbWUgPSBfLmNsb25lRGVlcChURVNUX0lOVEVOVCk7XG4gICAgICAgICAgICB0ZXN0SW50ZW50V2l0aFNhbWVOYW1lLnNhbXBsZXMgPSBbXTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW50ZXJhY3Rpb25Nb2RlbCA9IG5ldyBJbnRlcmFjdGlvbk1vZGVsR2VuZXJhdG9yKClcbiAgICAgICAgICAgICAgICAgICAgLmFkZEludGVudHMoVEVTVF9JTlRFTlQsIHRlc3RJbnRlbnRXaXRoU2FtZU5hbWUpXG4gICAgICAgICAgICAgICAgICAgIC53aXRoSW52b2NhdGlvbk5hbWUoJ3Rlc3QnKVxuICAgICAgICAgICAgICAgICAgICAuYnVpbGQoKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBleHBlY3QoZS5tZXNzYWdlKS5lcXVhbChgSW50ZW50ICR7dGVzdEludGVudFdpdGhTYW1lTmFtZS5uYW1lfSBpcyBkZWZpbmVkIG1vcmUgdGhhbiBvbmNlIGFuZCB0aGUgZGVmaW5pdGlvbnMgYXJlIG5vdCBpZGVudGljYWwuYCk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGV4cGVjdC5mYWlsKCdzaG91bGQgdGhyb3cgZXJyb3InKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBzdWl0ZSgnYWRkIHNsb3RUeXBlcyB0ZXN0cycsICgpID0+IHtcblxuICAgICAgICB0ZXN0KCdhZGRTbG90VHlwZXMgc2hvdWxkIHN1Y2Nlc3NmdWxseSBhZGQgc2luZ2xlIHNsb3RUeXBlIHRvIElNJywgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaW50ZXJhY3Rpb25Nb2RlbCA9IG5ldyBJbnRlcmFjdGlvbk1vZGVsR2VuZXJhdG9yKClcbiAgICAgICAgICAgICAgICAuYWRkT3JNZXJnZVNsb3RUeXBlcyhURVNUX1NMT1RfVFlQRSlcbiAgICAgICAgICAgICAgICAud2l0aEludm9jYXRpb25OYW1lKFRFU1RfSU5WT0NBVElPTl9OQU1FKVxuICAgICAgICAgICAgICAgIC5idWlsZCgpO1xuXG4gICAgICAgICAgICBjb25zdCBleHBlY3RlZEludGVyYWN0aW9uTW9kZWw6IEludGVyYWN0aW9uTW9kZWxEYXRhID0ge1xuICAgICAgICAgICAgICAgIGludGVyYWN0aW9uTW9kZWw6IHtcbiAgICAgICAgICAgICAgICAgICAgbGFuZ3VhZ2VNb2RlbDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW52b2NhdGlvbk5hbWU6IFRFU1RfSU5WT0NBVElPTl9OQU1FLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZW50czogW10sXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlczogW1RFU1RfU0xPVF9UWVBFXVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBwcm9tcHRzOiBbXVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBleHBlY3QoaW50ZXJhY3Rpb25Nb2RlbCkuZGVlcC5lcXVhbChleHBlY3RlZEludGVyYWN0aW9uTW9kZWwpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0ZXN0KCdhZGRTbG90VHlwZXMgc2hvdWxkIG5vdCBhZGQgZHVwbGljYXRlIHNsb3RUeXBlIHRvIElNJywgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaW50ZXJhY3Rpb25Nb2RlbCA9IG5ldyBJbnRlcmFjdGlvbk1vZGVsR2VuZXJhdG9yKClcbiAgICAgICAgICAgICAgICAuYWRkT3JNZXJnZVNsb3RUeXBlcyhURVNUX1NMT1RfVFlQRSwgVEVTVF9TTE9UX1RZUEUpXG4gICAgICAgICAgICAgICAgLndpdGhJbnZvY2F0aW9uTmFtZShURVNUX0lOVk9DQVRJT05fTkFNRSlcbiAgICAgICAgICAgICAgICAuYnVpbGQoKTtcblxuICAgICAgICAgICAgY29uc3QgZXhwZWN0ZWRJbnRlcmFjdGlvbk1vZGVsOiBJbnRlcmFjdGlvbk1vZGVsRGF0YSA9IHtcbiAgICAgICAgICAgICAgICBpbnRlcmFjdGlvbk1vZGVsOiB7XG4gICAgICAgICAgICAgICAgICAgIGxhbmd1YWdlTW9kZWw6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludm9jYXRpb25OYW1lOiBURVNUX0lOVk9DQVRJT05fTkFNRSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVudHM6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZXM6IFtURVNUX1NMT1RfVFlQRV1cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgcHJvbXB0czogW11cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgZXhwZWN0KGludGVyYWN0aW9uTW9kZWwpLmRlZXAuZXF1YWwoZXhwZWN0ZWRJbnRlcmFjdGlvbk1vZGVsKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGVzdCgnYWRkU2xvdFR5cGVzIHNob3VsZCB0aHJvdyBlcnJvciB3aGVuIHR3byBzbG90VHlwZVZhbHVlIGhhcyBzYW1lIGlkIGJ1dCBkaWZmZXJlbnQgbmFtZS52YWx1ZScsICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG1vZGlmaWVkVGVzdFNsb3RUeXBlID0gXy5jbG9uZURlZXAoVEVTVF9TTE9UX1RZUEUpO1xuICAgICAgICAgICAgbW9kaWZpZWRUZXN0U2xvdFR5cGUudmFsdWVzIVswXS5uYW1lIS52YWx1ZSA9ICcnO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbnRlcmFjdGlvbk1vZGVsID0gbmV3IEludGVyYWN0aW9uTW9kZWxHZW5lcmF0b3IoKVxuICAgICAgICAgICAgICAgICAgICAuYWRkT3JNZXJnZVNsb3RUeXBlcyhURVNUX1NMT1RfVFlQRSwgbW9kaWZpZWRUZXN0U2xvdFR5cGUpXG4gICAgICAgICAgICAgICAgICAgIC53aXRoSW52b2NhdGlvbk5hbWUoVEVTVF9JTlZPQ0FUSU9OX05BTUUpXG4gICAgICAgICAgICAgICAgICAgIC5idWlsZCgpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGV4cGVjdChlLm1lc3NhZ2UpLmVxdWFsKGBDYW5ub3QgbWVyZ2Ugc2xvdCB0eXBlICR7VEVTVF9TTE9UX1RZUEUubmFtZX0sIGFzIHRoZSB2YWx1ZSAke0pTT04uc3RyaW5naWZ5KG1vZGlmaWVkVGVzdFNsb3RUeXBlLnZhbHVlcyFbMF0pfSBhbmQgJHtKU09OLnN0cmluZ2lmeShURVNUX1NMT1RfVFlQRS52YWx1ZXMhWzBdKX0gaGFzIHRoZSBzYW1lIGlkIGJ1dCBkaWZmZXJlbnQgbmFtZS52YWx1ZS5gKTtcblxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZXhwZWN0LmZhaWwoJ3Nob3VsZCB0aHJvdyBlcnJvcicpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0ZXN0KCdhZGRTbG90VHlwZXMgc2hvdWxkIHRocm93IGVycm9yIHdoZW4gdHdvIHNsb3RUeXBlVmFsdWUgaGFzIHNhbWUgbmFtZS52YWx1ZSBidXQgZGlmZmVyZW50IGlkJywgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbW9kaWZpZWRUZXN0U2xvdFR5cGUgPSBfLmNsb25lRGVlcChURVNUX1NMT1RfVFlQRSk7XG4gICAgICAgICAgICBtb2RpZmllZFRlc3RTbG90VHlwZS52YWx1ZXMhWzBdLmlkID0gJyc7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGludGVyYWN0aW9uTW9kZWwgPSBuZXcgSW50ZXJhY3Rpb25Nb2RlbEdlbmVyYXRvcigpXG4gICAgICAgICAgICAgICAgICAgIC5hZGRPck1lcmdlU2xvdFR5cGVzKFRFU1RfU0xPVF9UWVBFLCBtb2RpZmllZFRlc3RTbG90VHlwZSlcbiAgICAgICAgICAgICAgICAgICAgLndpdGhJbnZvY2F0aW9uTmFtZShURVNUX0lOVk9DQVRJT05fTkFNRSlcbiAgICAgICAgICAgICAgICAgICAgLmJ1aWxkKCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgZXhwZWN0KGUubWVzc2FnZSkuZXF1YWwoYENhbm5vdCBtZXJnZSBzbG90IHR5cGUgJHtURVNUX1NMT1RfVFlQRS5uYW1lfSwgYXMgdGhlIHZhbHVlICR7SlNPTi5zdHJpbmdpZnkobW9kaWZpZWRUZXN0U2xvdFR5cGUudmFsdWVzIVswXSl9IGFuZCAke0pTT04uc3RyaW5naWZ5KFRFU1RfU0xPVF9UWVBFLnZhbHVlcyFbMF0pfSBoYXMgdGhlIHNhbWUgbmFtZS52YWx1ZSBidXQgZGlmZmVyZW50IGlkLmApO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBleHBlY3QuZmFpbCgnc2hvdWxkIHRocm93IGVycm9yJyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRlc3QoJ2FkZFNsb3RUeXBlcyBzaG91bGQgYmUgYWJsZSB0byBtZXJnZSBzeW5vbnltcycsICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5ld1Nsb3RUeXBlID0gXy5jbG9uZURlZXAoVEVTVF9TTE9UX1RZUEUpO1xuICAgICAgICAgICAgbmV3U2xvdFR5cGUudmFsdWVzIVswXS5uYW1lIS5zeW5vbnltcyA9IFsnbmV3IHN5bm9ueW0nXTtcbiAgICAgICAgICAgIGNvbnN0IGludGVyYWN0aW9uTW9kZWwgPSBuZXcgSW50ZXJhY3Rpb25Nb2RlbEdlbmVyYXRvcigpXG4gICAgICAgICAgICAgICAgLmFkZE9yTWVyZ2VTbG90VHlwZXMoVEVTVF9TTE9UX1RZUEUsIG5ld1Nsb3RUeXBlKVxuICAgICAgICAgICAgICAgIC53aXRoSW52b2NhdGlvbk5hbWUoVEVTVF9JTlZPQ0FUSU9OX05BTUUpXG4gICAgICAgICAgICAgICAgLmJ1aWxkKCk7XG5cbiAgICAgICAgICAgIGNvbnN0IGV4cGVjdGVkSW50ZXJhY3Rpb25Nb2RlbDogSW50ZXJhY3Rpb25Nb2RlbERhdGEgPSB7XG4gICAgICAgICAgICAgICAgaW50ZXJhY3Rpb25Nb2RlbDoge1xuICAgICAgICAgICAgICAgICAgICBsYW5ndWFnZU1vZGVsOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnZvY2F0aW9uTmFtZTogVEVTVF9JTlZPQ0FUSU9OX05BTUUsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlbnRzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVzOiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdURVNUJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6ICdURVNUX0lEJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogJ1RFU1RfVkFMVUUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bm9ueW1zOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdURVNUX1NZTk9OWU1TJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ25ldyBzeW5vbnltJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1dXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHByb21wdHM6IFtdXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGV4cGVjdChpbnRlcmFjdGlvbk1vZGVsKS5kZWVwLmVxdWFsKGV4cGVjdGVkSW50ZXJhY3Rpb25Nb2RlbCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRlc3QoJ2FkZFZhbHVlc1RvU2xvdFR5cGUgc2hvdWxkIHRocm93IGVycm9yIHdoZW4gdGhlIHNsb3ROYW1lIGlzIG5vdCBleGlzdCcsICgpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW50ZXJhY3Rpb25Nb2RlbCA9IG5ldyBJbnRlcmFjdGlvbk1vZGVsR2VuZXJhdG9yKClcbiAgICAgICAgICAgICAgICAgICAgLmFkZFZhbHVlc1RvU2xvdFR5cGUoJ05hbWUnLCBURVNUX1NMT1RfVFlQRV9WQUxVRSlcbiAgICAgICAgICAgICAgICAgICAgLndpdGhJbnZvY2F0aW9uTmFtZShURVNUX0lOVk9DQVRJT05fTkFNRSlcbiAgICAgICAgICAgICAgICAgICAgLmJ1aWxkKCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgZXhwZWN0KGUubWVzc2FnZSkuZXF1YWwoYFNsb3RUeXBlIE5hbWUgaXMgbm90IGRlZmluZWQuYCk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGV4cGVjdC5mYWlsKCdzaG91bGQgdGhyb3cgZXJyb3InKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGVzdCgnYWRkVmFsdWVzVG9TbG90VHlwZSBzaG91bGQgc3VjY2Vzc2Z1bGx5IGFkZCB2YWx1ZSB0byBleGlzdCBzbG90VHlwZScsICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGV4dHJhU2xvdFZhbHVlID0ge1xuICAgICAgICAgICAgICAgIGlkOiAnRVhUUkFfSUQnLFxuICAgICAgICAgICAgICAgIG5hbWU6IHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6ICdFWFRSQV9WQUxVRScsXG4gICAgICAgICAgICAgICAgICAgIHN5bm9ueW1zOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnRVhUUkFfU1lOT05ZTVMnXG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgaW50ZXJhY3Rpb25Nb2RlbCA9IG5ldyBJbnRlcmFjdGlvbk1vZGVsR2VuZXJhdG9yKClcbiAgICAgICAgICAgICAgICAuYWRkT3JNZXJnZVNsb3RUeXBlcyhURVNUX1NMT1RfVFlQRSlcbiAgICAgICAgICAgICAgICAuYWRkVmFsdWVzVG9TbG90VHlwZShURVNUX1NMT1RfVFlQRS5uYW1lISwgZXh0cmFTbG90VmFsdWUpXG4gICAgICAgICAgICAgICAgLndpdGhJbnZvY2F0aW9uTmFtZShURVNUX0lOVk9DQVRJT05fTkFNRSlcbiAgICAgICAgICAgICAgICAuYnVpbGQoKTtcbiAgICAgICAgICAgIGNvbnN0IGV4cGVjdGVkSW50ZXJhY3Rpb25Nb2RlbDogSW50ZXJhY3Rpb25Nb2RlbERhdGEgPSB7XG4gICAgICAgICAgICAgICAgaW50ZXJhY3Rpb25Nb2RlbDoge1xuICAgICAgICAgICAgICAgICAgICBsYW5ndWFnZU1vZGVsOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnZvY2F0aW9uTmFtZTogVEVTVF9JTlZPQ0FUSU9OX05BTUUsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlbnRzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVzOiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdURVNUJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVEVTVF9TTE9UX1RZUEVfVkFMVUUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dHJhU2xvdFZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgICAgICAgfV1cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgcHJvbXB0czogW11cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgZXhwZWN0KGludGVyYWN0aW9uTW9kZWwpLmRlZXAuZXF1YWwoZXhwZWN0ZWRJbnRlcmFjdGlvbk1vZGVsKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBzdWl0ZSgnYWRkIGRpYWxvZ0ludGVudHMgdGVzdHMnLCAoKSA9PiB7XG4gICAgICAgIHRlc3QoJ2FkZERpYWxvZ0ludGVudHMgc2hvdWxkIHN1Y2Nlc3NmdWxseSBhZGQgc2luZ2xlIGludGVudCB0byBJTScsICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGludGVyYWN0aW9uTW9kZWwgPSBuZXcgSW50ZXJhY3Rpb25Nb2RlbEdlbmVyYXRvcigpXG4gICAgICAgICAgICAgICAgLmFkZERpYWxvZ0ludGVudHMoVEVTVF9ESUFMT0dfSU5URU5UKVxuICAgICAgICAgICAgICAgIC53aXRoSW52b2NhdGlvbk5hbWUoVEVTVF9JTlZPQ0FUSU9OX05BTUUpXG4gICAgICAgICAgICAgICAgLmJ1aWxkKCk7XG5cbiAgICAgICAgICAgIGNvbnN0IGV4cGVjdGVkSW50ZXJhY3Rpb25Nb2RlbDogSW50ZXJhY3Rpb25Nb2RlbERhdGEgPSB7XG4gICAgICAgICAgICAgICAgaW50ZXJhY3Rpb25Nb2RlbDoge1xuICAgICAgICAgICAgICAgICAgICBsYW5ndWFnZU1vZGVsOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnZvY2F0aW9uTmFtZTogVEVTVF9JTlZPQ0FUSU9OX05BTUUsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlbnRzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVzOiBbXVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBkaWFsb2c6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVudHM6IFtURVNUX0RJQUxPR19JTlRFTlRdXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHByb21wdHM6IFtdXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGV4cGVjdChpbnRlcmFjdGlvbk1vZGVsKS5kZWVwLmVxdWFsKGV4cGVjdGVkSW50ZXJhY3Rpb25Nb2RlbCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRlc3QoJ2FkZERpYWxvZ0ludGVudHMgc2hvdWxkIG5vdCBhZGQgZHVwbGljYXRlIGRpYWxvZ0ludGVudCcsICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGludGVyYWN0aW9uTW9kZWwgPSBuZXcgSW50ZXJhY3Rpb25Nb2RlbEdlbmVyYXRvcigpXG4gICAgICAgICAgICAgICAgLmFkZERpYWxvZ0ludGVudHMoVEVTVF9ESUFMT0dfSU5URU5ULCBURVNUX0RJQUxPR19JTlRFTlQpXG4gICAgICAgICAgICAgICAgLndpdGhJbnZvY2F0aW9uTmFtZShURVNUX0lOVk9DQVRJT05fTkFNRSlcbiAgICAgICAgICAgICAgICAuYnVpbGQoKTtcblxuICAgICAgICAgICAgY29uc3QgZXhwZWN0ZWRJbnRlcmFjdGlvbk1vZGVsOiBJbnRlcmFjdGlvbk1vZGVsRGF0YSA9IHtcbiAgICAgICAgICAgICAgICBpbnRlcmFjdGlvbk1vZGVsOiB7XG4gICAgICAgICAgICAgICAgICAgIGxhbmd1YWdlTW9kZWw6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludm9jYXRpb25OYW1lOiBURVNUX0lOVk9DQVRJT05fTkFNRSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVudHM6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZXM6IFtdXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGRpYWxvZzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZW50czogW1RFU1RfRElBTE9HX0lOVEVOVF1cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgcHJvbXB0czogW11cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgZXhwZWN0KGludGVyYWN0aW9uTW9kZWwpLmRlZXAuZXF1YWwoZXhwZWN0ZWRJbnRlcmFjdGlvbk1vZGVsKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGVzdCgnYWRkRGlhbG9nSW50ZW50cyBzaG91bGQgdGhyb3cgZXJyb3Igd2hlbiBhbiBkaWFsb2dJbnRlbnQgaXMgZGVmaW5lZCBtb3JlIHRoYW4gb25jZScsICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRlc3RJbnRlbnRXaXRoU2FtZU5hbWUgPSBfLmNsb25lRGVlcChURVNUX0RJQUxPR19JTlRFTlQpO1xuICAgICAgICAgICAgdGVzdEludGVudFdpdGhTYW1lTmFtZS5zbG90cyA9IFtdO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbnRlcmFjdGlvbk1vZGVsID0gbmV3IEludGVyYWN0aW9uTW9kZWxHZW5lcmF0b3IoKVxuICAgICAgICAgICAgICAgICAgICAuYWRkRGlhbG9nSW50ZW50cyhURVNUX0RJQUxPR19JTlRFTlQsIHRlc3RJbnRlbnRXaXRoU2FtZU5hbWUpXG4gICAgICAgICAgICAgICAgICAgIC53aXRoSW52b2NhdGlvbk5hbWUoJ3Rlc3QnKVxuICAgICAgICAgICAgICAgICAgICAuYnVpbGQoKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBleHBlY3QoZS5tZXNzYWdlKS5lcXVhbChgRGlhbG9nSW50ZW50ICR7dGVzdEludGVudFdpdGhTYW1lTmFtZS5uYW1lfSBpcyBkZWZpbmVkIG1vcmUgdGhhbiBvbmNlIGFuZCB0aGUgZGVmaW5pdGlvbnMgYXJlIG5vdCBpZGVudGljYWwuYCk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGV4cGVjdC5mYWlsKCdzaG91bGQgdGhyb3cgZXJyb3InKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBzdWl0ZSgnYWRkIHByb21wdHMgdGVzdHMnLCAoKSA9PiB7XG4gICAgICAgIHRlc3QoJ2FkZFByb21wdHMgc2hvdWxkIHN1Y2Nlc3NmdWxseSBhZGQgc2luZ2xlIHByb21wdCB0byBJTScsICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGludGVyYWN0aW9uTW9kZWwgPSBuZXcgSW50ZXJhY3Rpb25Nb2RlbEdlbmVyYXRvcigpXG4gICAgICAgICAgICAgICAgLmFkZFByb21wdHMoVEVTVF9QUk9NUFQpXG4gICAgICAgICAgICAgICAgLndpdGhJbnZvY2F0aW9uTmFtZShURVNUX0lOVk9DQVRJT05fTkFNRSlcbiAgICAgICAgICAgICAgICAuYnVpbGQoKTtcblxuICAgICAgICAgICAgY29uc3QgZXhwZWN0ZWRJbnRlcmFjdGlvbk1vZGVsOiBJbnRlcmFjdGlvbk1vZGVsRGF0YSA9IHtcbiAgICAgICAgICAgICAgICBpbnRlcmFjdGlvbk1vZGVsOiB7XG4gICAgICAgICAgICAgICAgICAgIGxhbmd1YWdlTW9kZWw6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludm9jYXRpb25OYW1lOiBURVNUX0lOVk9DQVRJT05fTkFNRSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVudHM6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZXM6IFtdXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHByb21wdHM6IFtURVNUX1BST01QVF1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgZXhwZWN0KGludGVyYWN0aW9uTW9kZWwpLmRlZXAuZXF1YWwoZXhwZWN0ZWRJbnRlcmFjdGlvbk1vZGVsKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGVzdCgnYWRkUHJvbXB0cyBzaG91bGQgbm90IGFkZCBkdXBsaWNhdGUgcHJvbXB0JywgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaW50ZXJhY3Rpb25Nb2RlbCA9IG5ldyBJbnRlcmFjdGlvbk1vZGVsR2VuZXJhdG9yKClcbiAgICAgICAgICAgICAgICAuYWRkUHJvbXB0cyhURVNUX1BST01QVCwgVEVTVF9QUk9NUFQpXG4gICAgICAgICAgICAgICAgLndpdGhJbnZvY2F0aW9uTmFtZShURVNUX0lOVk9DQVRJT05fTkFNRSlcbiAgICAgICAgICAgICAgICAuYnVpbGQoKTtcblxuICAgICAgICAgICAgY29uc3QgZXhwZWN0ZWRJbnRlcmFjdGlvbk1vZGVsOiBJbnRlcmFjdGlvbk1vZGVsRGF0YSA9IHtcbiAgICAgICAgICAgICAgICBpbnRlcmFjdGlvbk1vZGVsOiB7XG4gICAgICAgICAgICAgICAgICAgIGxhbmd1YWdlTW9kZWw6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludm9jYXRpb25OYW1lOiBURVNUX0lOVk9DQVRJT05fTkFNRSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVudHM6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZXM6IFtdXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHByb21wdHM6IFtURVNUX1BST01QVF1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgZXhwZWN0KGludGVyYWN0aW9uTW9kZWwpLmRlZXAuZXF1YWwoZXhwZWN0ZWRJbnRlcmFjdGlvbk1vZGVsKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGVzdCgnYWRkUHJvbXB0cyBzaG91bGQgdGhyb3cgZXJyb3Igd2hlbiBhbiBwcm9tcHQgaXMgZGVmaW5lZCBtb3JlIHRoYW4gb25jZScsICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRlc3RQcm9tcHRXaXRoU2FtZUlkID0gXy5jbG9uZURlZXAoVEVTVF9QUk9NUFQpO1xuICAgICAgICAgICAgdGVzdFByb21wdFdpdGhTYW1lSWQudmFyaWF0aW9ucyA9IFtdO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbnRlcmFjdGlvbk1vZGVsID0gbmV3IEludGVyYWN0aW9uTW9kZWxHZW5lcmF0b3IoKVxuICAgICAgICAgICAgICAgICAgICAuYWRkUHJvbXB0cyhURVNUX1BST01QVCwgdGVzdFByb21wdFdpdGhTYW1lSWQpXG4gICAgICAgICAgICAgICAgICAgIC53aXRoSW52b2NhdGlvbk5hbWUoJ3Rlc3QnKVxuICAgICAgICAgICAgICAgICAgICAuYnVpbGQoKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBleHBlY3QoZS5tZXNzYWdlKS5lcXVhbChgUHJvbXB0IHdpdGggaWQgJHtURVNUX1BST01QVC5pZH0gaXMgZGVmaW5lZCBtb3JlIHRoYW4gb25jZSBhbmQgdGhlIGRlZmluaXRpb25zIGFyZSBub3QgaWRlbnRpY2FsLmApO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBleHBlY3QuZmFpbCgnc2hvdWxkIHRocm93IGVycm9yJyk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgc3VpdGUoJ0hpZ2ggbGV2ZWwgZnVuY3Rpb24gdGVzdHMnLCAoKSA9PiB7XG4gICAgICAgIHRlc3QoJ3Nob3VsZCBiZSBhYmxlIHRvIHRocm93IGVycm9yIHdoZW4gaW5wdXQgZmlsZSBub3QgZXhpc3QnLCAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpbnZhbGlkRmlsZVBhdGggPSBqb2luKF9fZGlybmFtZSwgJ2ludmFsaWRGaWxlLmpzb24nKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW50ZXJhY3Rpb25Nb2RlbCA9IG5ldyBJbnRlcmFjdGlvbk1vZGVsR2VuZXJhdG9yKCkubG9hZEZyb21GaWxlKGludmFsaWRGaWxlUGF0aCkuYnVpbGQoKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBleHBlY3QoZS5tZXNzYWdlKS5lcXVhbCgnSW5wdXQgcGF0aCBpcyBub3QgdmFsaWQuJyk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGV4cGVjdC5mYWlsKCdzaG91bGQgdGhyb3cgZXJyb3InKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGVzdCgnc2hvdWxkIGJlIGFibGUgdG8gZ2VuZXJhdGUgSW50ZXJhY3Rpb25Nb2RlbCBieSByZWFkaW5nIGV4aXN0IG1vZGVscycsICgpID0+IHtcblxuICAgICAgICAgICAgY29uc3QgaW50ZXJhY3Rpb25Nb2RlbCA9IG5ldyBJbnRlcmFjdGlvbk1vZGVsR2VuZXJhdG9yKCkubG9hZEZyb21GaWxlKG1vY2tGaWxlUGF0aCkuYnVpbGQoKTtcbiAgICAgICAgICAgIGV4cGVjdChpbnRlcmFjdGlvbk1vZGVsKS5kZWVwLmVxdWFsKGpzb25Qcm92aWRlci5sb2FkTW9ja0lucHV0RmlsZSgpKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGVzdCgnc2hvdWxkIGJlIGFibGUgdG8gYWRkIGN1c3RvbSBJbnRlbnQsIFNsb3RUeXBlcywgRGlhbG9nSW50ZW50cywgRGVsZWdhdGlvblN0cmF0ZWd5LCBJbnZvY2F0aW9uTmFtZSBieSB1c2luZyBmdW5jdGlvbiBjaGFpbicsICgpID0+IHtcblxuICAgICAgICAgICAgY29uc3QgaW50ZXJhY3Rpb25Nb2RlbDogSW50ZXJhY3Rpb25Nb2RlbERhdGEgPSBuZXcgSW50ZXJhY3Rpb25Nb2RlbEdlbmVyYXRvcigpXG4gICAgICAgICAgICAgICAgLmFkZEludGVudHMoVEVTVF9JTlRFTlQpXG4gICAgICAgICAgICAgICAgLmFkZE9yTWVyZ2VTbG90VHlwZXMoVEVTVF9TTE9UX1RZUEUpXG4gICAgICAgICAgICAgICAgLmFkZERpYWxvZ0ludGVudHMoVEVTVF9ESUFMT0dfSU5URU5UKVxuICAgICAgICAgICAgICAgIC5hZGREZWxlZ2F0aW9uU3RyYXRlZ3koVEVTVF9ERUxFR0FUSU9OX1NUUkFURUdZKVxuICAgICAgICAgICAgICAgIC53aXRoSW52b2NhdGlvbk5hbWUoVEVTVF9JTlZPQ0FUSU9OX05BTUUpXG4gICAgICAgICAgICAgICAgLmJ1aWxkKCk7XG4gICAgICAgICAgICBjb25zdCBleHBlY3RlZEludGVyYWN0aW9uTW9kZWw6IEludGVyYWN0aW9uTW9kZWxEYXRhID0ge1xuICAgICAgICAgICAgICAgIGludGVyYWN0aW9uTW9kZWw6IHtcbiAgICAgICAgICAgICAgICAgICAgbGFuZ3VhZ2VNb2RlbDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZW50czogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRFU1RfSU5URU5UXG4gICAgICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZXM6IFtURVNUX1NMT1RfVFlQRV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnZvY2F0aW9uTmFtZTogVEVTVF9JTlZPQ0FUSU9OX05BTUVcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZGlhbG9nOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxlZ2F0aW9uU3RyYXRlZ3k6IFRFU1RfREVMRUdBVElPTl9TVFJBVEVHWSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVudHM6IFtURVNUX0RJQUxPR19JTlRFTlRdXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHByb21wdHM6IFtdXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGV4cGVjdChpbnRlcmFjdGlvbk1vZGVsKS5kZWVwLmVxdWFsKGV4cGVjdGVkSW50ZXJhY3Rpb25Nb2RlbCk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG5cbn0pO1xuIl19